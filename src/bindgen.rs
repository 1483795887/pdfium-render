/* automatically generated by rust-bindgen 0.59.2 */

pub const FPDF_OBJECT_UNKNOWN: u32 = 0;
pub const FPDF_OBJECT_BOOLEAN: u32 = 1;
pub const FPDF_OBJECT_NUMBER: u32 = 2;
pub const FPDF_OBJECT_STRING: u32 = 3;
pub const FPDF_OBJECT_NAME: u32 = 4;
pub const FPDF_OBJECT_ARRAY: u32 = 5;
pub const FPDF_OBJECT_DICTIONARY: u32 = 6;
pub const FPDF_OBJECT_STREAM: u32 = 7;
pub const FPDF_OBJECT_NULLOBJ: u32 = 8;
pub const FPDF_OBJECT_REFERENCE: u32 = 9;
pub const FPDF_POLICY_MACHINETIME_ACCESS: u32 = 0;
pub const FPDF_ERR_SUCCESS: u32 = 0;
pub const FPDF_ERR_UNKNOWN: u32 = 1;
pub const FPDF_ERR_FILE: u32 = 2;
pub const FPDF_ERR_FORMAT: u32 = 3;
pub const FPDF_ERR_PASSWORD: u32 = 4;
pub const FPDF_ERR_SECURITY: u32 = 5;
pub const FPDF_ERR_PAGE: u32 = 6;
pub const FPDF_ANNOT: u32 = 1;
pub const FPDF_LCD_TEXT: u32 = 2;
pub const FPDF_NO_NATIVETEXT: u32 = 4;
pub const FPDF_GRAYSCALE: u32 = 8;
pub const FPDF_DEBUG_INFO: u32 = 128;
pub const FPDF_NO_CATCH: u32 = 256;
pub const FPDF_RENDER_LIMITEDIMAGECACHE: u32 = 512;
pub const FPDF_RENDER_FORCEHALFTONE: u32 = 1024;
pub const FPDF_PRINTING: u32 = 2048;
pub const FPDF_RENDER_NO_SMOOTHTEXT: u32 = 4096;
pub const FPDF_RENDER_NO_SMOOTHIMAGE: u32 = 8192;
pub const FPDF_RENDER_NO_SMOOTHPATH: u32 = 16384;
pub const FPDF_REVERSE_BYTE_ORDER: u32 = 16;
pub const FPDF_CONVERT_FILL_TO_STROKE: u32 = 32;
pub const FPDFBitmap_Unknown: u32 = 0;
pub const FPDFBitmap_Gray: u32 = 1;
pub const FPDFBitmap_BGR: u32 = 2;
pub const FPDFBitmap_BGRx: u32 = 3;
pub const FPDFBitmap_BGRA: u32 = 4;
pub const FORMTYPE_NONE: u32 = 0;
pub const FORMTYPE_ACRO_FORM: u32 = 1;
pub const FORMTYPE_XFA_FULL: u32 = 2;
pub const FORMTYPE_XFA_FOREGROUND: u32 = 3;
pub const FORMTYPE_COUNT: u32 = 4;
pub const JSPLATFORM_ALERT_BUTTON_OK: u32 = 0;
pub const JSPLATFORM_ALERT_BUTTON_OKCANCEL: u32 = 1;
pub const JSPLATFORM_ALERT_BUTTON_YESNO: u32 = 2;
pub const JSPLATFORM_ALERT_BUTTON_YESNOCANCEL: u32 = 3;
pub const JSPLATFORM_ALERT_BUTTON_DEFAULT: u32 = 0;
pub const JSPLATFORM_ALERT_ICON_ERROR: u32 = 0;
pub const JSPLATFORM_ALERT_ICON_WARNING: u32 = 1;
pub const JSPLATFORM_ALERT_ICON_QUESTION: u32 = 2;
pub const JSPLATFORM_ALERT_ICON_STATUS: u32 = 3;
pub const JSPLATFORM_ALERT_ICON_ASTERISK: u32 = 4;
pub const JSPLATFORM_ALERT_ICON_DEFAULT: u32 = 0;
pub const JSPLATFORM_ALERT_RETURN_OK: u32 = 1;
pub const JSPLATFORM_ALERT_RETURN_CANCEL: u32 = 2;
pub const JSPLATFORM_ALERT_RETURN_NO: u32 = 3;
pub const JSPLATFORM_ALERT_RETURN_YES: u32 = 4;
pub const JSPLATFORM_BEEP_ERROR: u32 = 0;
pub const JSPLATFORM_BEEP_WARNING: u32 = 1;
pub const JSPLATFORM_BEEP_QUESTION: u32 = 2;
pub const JSPLATFORM_BEEP_STATUS: u32 = 3;
pub const JSPLATFORM_BEEP_DEFAULT: u32 = 4;
pub const FXCT_ARROW: u32 = 0;
pub const FXCT_NESW: u32 = 1;
pub const FXCT_NWSE: u32 = 2;
pub const FXCT_VBEAM: u32 = 3;
pub const FXCT_HBEAM: u32 = 4;
pub const FXCT_HAND: u32 = 5;
pub const FPDFDOC_AACTION_WC: u32 = 16;
pub const FPDFDOC_AACTION_WS: u32 = 17;
pub const FPDFDOC_AACTION_DS: u32 = 18;
pub const FPDFDOC_AACTION_WP: u32 = 19;
pub const FPDFDOC_AACTION_DP: u32 = 20;
pub const FPDFPAGE_AACTION_OPEN: u32 = 0;
pub const FPDFPAGE_AACTION_CLOSE: u32 = 1;
pub const FPDF_FORMFIELD_UNKNOWN: u32 = 0;
pub const FPDF_FORMFIELD_PUSHBUTTON: u32 = 1;
pub const FPDF_FORMFIELD_CHECKBOX: u32 = 2;
pub const FPDF_FORMFIELD_RADIOBUTTON: u32 = 3;
pub const FPDF_FORMFIELD_COMBOBOX: u32 = 4;
pub const FPDF_FORMFIELD_LISTBOX: u32 = 5;
pub const FPDF_FORMFIELD_TEXTFIELD: u32 = 6;
pub const FPDF_FORMFIELD_SIGNATURE: u32 = 7;
pub const FPDF_FORMFIELD_COUNT: u32 = 8;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[doc = " Define 'max_align_t' to match the GCC definition."]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_UNKNOWN: FPDF_TEXT_RENDERMODE = -1;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL: FPDF_TEXT_RENDERMODE = 0;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_STROKE: FPDF_TEXT_RENDERMODE = 1;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_STROKE: FPDF_TEXT_RENDERMODE = 2;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_INVISIBLE: FPDF_TEXT_RENDERMODE = 3;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_CLIP: FPDF_TEXT_RENDERMODE = 4;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_STROKE_CLIP: FPDF_TEXT_RENDERMODE = 5;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_STROKE_CLIP: FPDF_TEXT_RENDERMODE = 6;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_CLIP: FPDF_TEXT_RENDERMODE = 7;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_LAST: FPDF_TEXT_RENDERMODE = 7;
#[doc = " PDF text rendering modes"]
pub type FPDF_TEXT_RENDERMODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_action_t__ {
    _unused: [u8; 0],
}
#[doc = " PDF types - use incomplete types (never completed) to force API type safety."]
pub type FPDF_ACTION = *mut fpdf_action_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_annotation_t__ {
    _unused: [u8; 0],
}
pub type FPDF_ANNOTATION = *mut fpdf_annotation_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_attachment_t__ {
    _unused: [u8; 0],
}
pub type FPDF_ATTACHMENT = *mut fpdf_attachment_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_avail_t__ {
    _unused: [u8; 0],
}
pub type FPDF_AVAIL = *mut fpdf_avail_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_bitmap_t__ {
    _unused: [u8; 0],
}
pub type FPDF_BITMAP = *mut fpdf_bitmap_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_bookmark_t__ {
    _unused: [u8; 0],
}
pub type FPDF_BOOKMARK = *mut fpdf_bookmark_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_clippath_t__ {
    _unused: [u8; 0],
}
pub type FPDF_CLIPPATH = *mut fpdf_clippath_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_dest_t__ {
    _unused: [u8; 0],
}
pub type FPDF_DEST = *mut fpdf_dest_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_document_t__ {
    _unused: [u8; 0],
}
pub type FPDF_DOCUMENT = *mut fpdf_document_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_font_t__ {
    _unused: [u8; 0],
}
pub type FPDF_FONT = *mut fpdf_font_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_form_handle_t__ {
    _unused: [u8; 0],
}
pub type FPDF_FORMHANDLE = *mut fpdf_form_handle_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_glyphpath_t__ {
    _unused: [u8; 0],
}
pub type FPDF_GLYPHPATH = *const fpdf_glyphpath_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_javascript_action_t {
    _unused: [u8; 0],
}
pub type FPDF_JAVASCRIPT_ACTION = *mut fpdf_javascript_action_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_link_t__ {
    _unused: [u8; 0],
}
pub type FPDF_LINK = *mut fpdf_link_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_page_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGE = *mut fpdf_page_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pagelink_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGELINK = *mut fpdf_pagelink_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pageobject_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGEOBJECT = *mut fpdf_pageobject_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pageobjectmark_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGEOBJECTMARK = *mut fpdf_pageobjectmark_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pagerange_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGERANGE = *mut fpdf_pagerange_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pathsegment_t {
    _unused: [u8; 0],
}
pub type FPDF_PATHSEGMENT = *const fpdf_pathsegment_t;
pub type FPDF_RECORDER = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_schhandle_t__ {
    _unused: [u8; 0],
}
pub type FPDF_SCHHANDLE = *mut fpdf_schhandle_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_signature_t__ {
    _unused: [u8; 0],
}
pub type FPDF_SIGNATURE = *mut fpdf_signature_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_structelement_t__ {
    _unused: [u8; 0],
}
pub type FPDF_STRUCTELEMENT = *mut fpdf_structelement_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_structtree_t__ {
    _unused: [u8; 0],
}
pub type FPDF_STRUCTTREE = *mut fpdf_structtree_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_textpage_t__ {
    _unused: [u8; 0],
}
pub type FPDF_TEXTPAGE = *mut fpdf_textpage_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_widget_t__ {
    _unused: [u8; 0],
}
pub type FPDF_WIDGET = *mut fpdf_widget_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_xobject_t__ {
    _unused: [u8; 0],
}
pub type FPDF_XOBJECT = *mut fpdf_xobject_t__;
#[doc = " Basic data types"]
pub type FPDF_BOOL = ::std::os::raw::c_int;
pub type FPDF_RESULT = ::std::os::raw::c_int;
pub type FPDF_DWORD = ::std::os::raw::c_ulong;
pub type FS_FLOAT = f32;
pub const _FPDF_DUPLEXTYPE__DuplexUndefined: _FPDF_DUPLEXTYPE_ = 0;
pub const _FPDF_DUPLEXTYPE__Simplex: _FPDF_DUPLEXTYPE_ = 1;
pub const _FPDF_DUPLEXTYPE__DuplexFlipShortEdge: _FPDF_DUPLEXTYPE_ = 2;
pub const _FPDF_DUPLEXTYPE__DuplexFlipLongEdge: _FPDF_DUPLEXTYPE_ = 3;
#[doc = " Duplex types"]
pub type _FPDF_DUPLEXTYPE_ = ::std::os::raw::c_uint;
#[doc = " Duplex types"]
pub use self::_FPDF_DUPLEXTYPE_ as FPDF_DUPLEXTYPE;
#[doc = " String types"]
pub type FPDF_WCHAR = ::std::os::raw::c_ushort;
#[doc = " FPDFSDK may use three types of strings: byte string, wide string (UTF-16LE"]
#[doc = " encoded), and platform dependent string"]
pub type FPDF_BYTESTRING = *const ::std::os::raw::c_char;
#[doc = " FPDFSDK always uses UTF-16LE encoded wide strings, each character uses 2"]
#[doc = " bytes (except surrogation), with the low byte first."]
pub type FPDF_WIDESTRING = *const ::std::os::raw::c_ushort;
#[doc = " Structure for persisting a string beyond the duration of a callback."]
#[doc = " Note: although represented as a char*, string may be interpreted as"]
#[doc = " a UTF-16LE formated string. Used only by XFA callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_BSTR_ {
    #[doc = " String buffer, manipulate only with FPDF_BStr_* methods."]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = " Length of the string, in bytes."]
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FPDF_BSTR_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_BSTR_>(),
        16usize,
        concat!("Size of: ", stringify!(FPDF_BSTR_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_BSTR_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_BSTR_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_BSTR_>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_BSTR_),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_BSTR_>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_BSTR_),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " Structure for persisting a string beyond the duration of a callback."]
#[doc = " Note: although represented as a char*, string may be interpreted as"]
#[doc = " a UTF-16LE formated string. Used only by XFA callbacks."]
pub type FPDF_BSTR = FPDF_BSTR_;
#[doc = " For Windows programmers: In most cases it's OK to treat FPDF_WIDESTRING as a"]
#[doc = " Windows unicode string, however, special care needs to be taken if you"]
#[doc = " expect to process Unicode larger than 0xffff."]
#[doc = ""]
#[doc = " For Linux/Unix programmers: most compiler/library environments use 4 bytes"]
#[doc = " for a Unicode character, and you have to convert between FPDF_WIDESTRING and"]
#[doc = " system wide string by yourself."]
pub type FPDF_STRING = *const ::std::os::raw::c_char;
#[doc = " Matrix for transformation, in the form [a b c d e f], equivalent to:"]
#[doc = " | a  b  0 |"]
#[doc = " | c  d  0 |"]
#[doc = " | e  f  1 |"]
#[doc = ""]
#[doc = " Translation is performed with [1 0 0 1 tx ty]."]
#[doc = " Scaling is performed with [sx 0 0 sy 0 0]."]
#[doc = " See PDF Reference 1.7, 4.2.2 Common Transformations for more."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_MATRIX_ {
    pub a: f32,
    pub b: f32,
    pub c: f32,
    pub d: f32,
    pub e: f32,
    pub f: f32,
}
#[test]
fn bindgen_test_layout__FS_MATRIX_() {
    assert_eq!(
        ::std::mem::size_of::<_FS_MATRIX_>(),
        24usize,
        concat!("Size of: ", stringify!(_FS_MATRIX_))
    );
    assert_eq!(
        ::std::mem::align_of::<_FS_MATRIX_>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_MATRIX_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).b as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).c as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).d as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).e as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).f as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(f)
        )
    );
}
#[doc = " Matrix for transformation, in the form [a b c d e f], equivalent to:"]
#[doc = " | a  b  0 |"]
#[doc = " | c  d  0 |"]
#[doc = " | e  f  1 |"]
#[doc = ""]
#[doc = " Translation is performed with [1 0 0 1 tx ty]."]
#[doc = " Scaling is performed with [sx 0 0 sy 0 0]."]
#[doc = " See PDF Reference 1.7, 4.2.2 Common Transformations for more."]
pub type FS_MATRIX = _FS_MATRIX_;
#[doc = " Rectangle area(float) in device or page coordinate system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_RECTF_ {
    #[doc = " The x-coordinate of the left-top corner."]
    pub left: f32,
    #[doc = " The y-coordinate of the left-top corner."]
    pub top: f32,
    #[doc = " The x-coordinate of the right-bottom corner."]
    pub right: f32,
    #[doc = " The y-coordinate of the right-bottom corner."]
    pub bottom: f32,
}
#[test]
fn bindgen_test_layout__FS_RECTF_() {
    assert_eq!(
        ::std::mem::size_of::<_FS_RECTF_>(),
        16usize,
        concat!("Size of: ", stringify!(_FS_RECTF_))
    );
    assert_eq!(
        ::std::mem::align_of::<_FS_RECTF_>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_RECTF_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " Rectangle area(float) in device or page coordinate system."]
pub type FS_LPRECTF = *mut _FS_RECTF_;
#[doc = " Rectangle area(float) in device or page coordinate system."]
pub type FS_RECTF = _FS_RECTF_;
#[doc = " Const Pointer to FS_RECTF structure."]
pub type FS_LPCRECTF = *const FS_RECTF;
#[doc = " Rectangle size. Coordinate system agnostic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_SIZEF_ {
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_FS_SIZEF_() {
    assert_eq!(
        ::std::mem::size_of::<FS_SIZEF_>(),
        8usize,
        concat!("Size of: ", stringify!(FS_SIZEF_))
    );
    assert_eq!(
        ::std::mem::align_of::<FS_SIZEF_>(),
        4usize,
        concat!("Alignment of ", stringify!(FS_SIZEF_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_SIZEF_>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_SIZEF_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_SIZEF_>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_SIZEF_),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Rectangle size. Coordinate system agnostic."]
pub type FS_LPSIZEF = *mut FS_SIZEF_;
#[doc = " Rectangle size. Coordinate system agnostic."]
pub type FS_SIZEF = FS_SIZEF_;
#[doc = " Const Pointer to FS_SIZEF structure."]
pub type FS_LPCSIZEF = *const FS_SIZEF;
#[doc = " 2D Point. Coordinate system agnostic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_POINTF_ {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_FS_POINTF_() {
    assert_eq!(
        ::std::mem::size_of::<FS_POINTF_>(),
        8usize,
        concat!("Size of: ", stringify!(FS_POINTF_))
    );
    assert_eq!(
        ::std::mem::align_of::<FS_POINTF_>(),
        4usize,
        concat!("Alignment of ", stringify!(FS_POINTF_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_POINTF_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_POINTF_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_POINTF_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_POINTF_),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " 2D Point. Coordinate system agnostic."]
pub type FS_LPPOINTF = *mut FS_POINTF_;
#[doc = " 2D Point. Coordinate system agnostic."]
pub type FS_POINTF = FS_POINTF_;
#[doc = " Const Pointer to FS_POINTF structure."]
pub type FS_LPCPOINTF = *const FS_POINTF;
#[doc = " Annotation enums."]
pub type FPDF_ANNOTATION_SUBTYPE = ::std::os::raw::c_int;
pub type FPDF_ANNOT_APPEARANCEMODE = ::std::os::raw::c_int;
#[doc = " Dictionary value types."]
pub type FPDF_OBJECT_TYPE = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Function: FPDF_InitLibrary"]
    #[doc = "          Initialize the FPDFSDK library"]
    #[doc = " Parameters:"]
    #[doc = "          None"]
    #[doc = " Return value:"]
    #[doc = "          None."]
    #[doc = " Comments:"]
    #[doc = "          Convenience function to call FPDF_InitLibraryWithConfig() for"]
    #[doc = "          backwards compatibility purposes. This will be deprecated in the"]
    #[doc = "          future."]
    pub fn FPDF_InitLibrary();
}
#[doc = " Process-wide options for initializing the library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_LIBRARY_CONFIG_ {
    #[doc = " Version number of the interface. Currently must be 2."]
    #[doc = " Support for version 1 will be deprecated in the future."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Array of paths to scan in place of the defaults when using built-in"]
    #[doc = " FXGE font loading code. The array is terminated by a NULL pointer."]
    #[doc = " The Array may be NULL itself to use the default paths. May be ignored"]
    #[doc = " entirely depending upon the platform."]
    pub m_pUserFontPaths: *mut *const ::std::os::raw::c_char,
    #[doc = " Pointer to the v8::Isolate to use, or NULL to force PDFium to create one."]
    pub m_pIsolate: *mut ::std::os::raw::c_void,
    #[doc = " The embedder data slot to use in the v8::Isolate to store PDFium's"]
    #[doc = " per-isolate data. The value needs to be in the range"]
    #[doc = " [0, |v8::Internals::kNumIsolateDataLots|). Note that 0 is fine for most"]
    #[doc = " embedders."]
    pub m_v8EmbedderSlot: ::std::os::raw::c_uint,
    #[doc = " Pointer to the V8::Platform to use."]
    pub m_pPlatform: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FPDF_LIBRARY_CONFIG_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_LIBRARY_CONFIG_>(),
        40usize,
        concat!("Size of: ", stringify!(FPDF_LIBRARY_CONFIG_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_LIBRARY_CONFIG_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_LIBRARY_CONFIG_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_pUserFontPaths as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pUserFontPaths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_pIsolate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pIsolate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_v8EmbedderSlot as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_v8EmbedderSlot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_pPlatform as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pPlatform)
        )
    );
}
#[doc = " Process-wide options for initializing the library."]
pub type FPDF_LIBRARY_CONFIG = FPDF_LIBRARY_CONFIG_;
extern "C" {
    #[doc = " Function: FPDF_InitLibraryWithConfig"]
    #[doc = "          Initialize the FPDFSDK library"]
    #[doc = " Parameters:"]
    #[doc = "          config - configuration information as above."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    #[doc = " Comments:"]
    #[doc = "          You have to call this function before you can call any PDF"]
    #[doc = "          processing functions."]
    pub fn FPDF_InitLibraryWithConfig(config: *const FPDF_LIBRARY_CONFIG);
}
extern "C" {
    #[doc = " Function: FPDF_DestroyLibary"]
    #[doc = "          Release all resources allocated by the FPDFSDK library."]
    #[doc = " Parameters:"]
    #[doc = "          None."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    #[doc = " Comments:"]
    #[doc = "          You can call this function to release all memory blocks allocated by"]
    #[doc = "          the library."]
    #[doc = "          After this function is called, you should not call any PDF"]
    #[doc = "          processing functions."]
    pub fn FPDF_DestroyLibrary();
}
extern "C" {
    #[doc = " Function: FPDF_SetSandBoxPolicy"]
    #[doc = "          Set the policy for the sandbox environment."]
    #[doc = " Parameters:"]
    #[doc = "          policy -   The specified policy for setting, for example:"]
    #[doc = "                     FPDF_POLICY_MACHINETIME_ACCESS."]
    #[doc = "          enable -   True to enable, false to disable the policy."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    pub fn FPDF_SetSandBoxPolicy(policy: FPDF_DWORD, enable: FPDF_BOOL);
}
extern "C" {
    #[doc = " Function: FPDF_LoadDocument"]
    #[doc = "          Open and load a PDF document."]
    #[doc = " Parameters:"]
    #[doc = "          file_path -  Path to the PDF file (including extension)."]
    #[doc = "          password  -  A string used as the password for the PDF file."]
    #[doc = "                       If no password is needed, empty or NULL can be used."]
    #[doc = "                       See comments below regarding the encoding."]
    #[doc = " Return value:"]
    #[doc = "          A handle to the loaded document, or NULL on failure."]
    #[doc = " Comments:"]
    #[doc = "          Loaded document can be closed by FPDF_CloseDocument()."]
    #[doc = "          If this function fails, you can use FPDF_GetLastError() to retrieve"]
    #[doc = "          the reason why it failed."]
    #[doc = ""]
    #[doc = "          The encoding for |password| can be either UTF-8 or Latin-1. PDFs,"]
    #[doc = "          depending on the security handler revision, will only accept one or"]
    #[doc = "          the other encoding. If |password|'s encoding and the PDF's expected"]
    #[doc = "          encoding do not match, FPDF_LoadDocument() will automatically"]
    #[doc = "          convert |password| to the other encoding."]
    pub fn FPDF_LoadDocument(file_path: FPDF_STRING, password: FPDF_BYTESTRING) -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Function: FPDF_LoadMemDocument"]
    #[doc = "          Open and load a PDF document from memory."]
    #[doc = " Parameters:"]
    #[doc = "          data_buf    -   Pointer to a buffer containing the PDF document."]
    #[doc = "          size        -   Number of bytes in the PDF document."]
    #[doc = "          password    -   A string used as the password for the PDF file."]
    #[doc = "                          If no password is needed, empty or NULL can be used."]
    #[doc = " Return value:"]
    #[doc = "          A handle to the loaded document, or NULL on failure."]
    #[doc = " Comments:"]
    #[doc = "          The memory buffer must remain valid when the document is open."]
    #[doc = "          The loaded document can be closed by FPDF_CloseDocument."]
    #[doc = "          If this function fails, you can use FPDF_GetLastError() to retrieve"]
    #[doc = "          the reason why it failed."]
    #[doc = ""]
    #[doc = "          See the comments for FPDF_LoadDocument() regarding the encoding for"]
    #[doc = "          |password|."]
    #[doc = " Notes:"]
    #[doc = "          If PDFium is built with the XFA module, the application should call"]
    #[doc = "          FPDF_LoadXFA() function after the PDF document loaded to support XFA"]
    #[doc = "          fields defined in the fpdfformfill.h file."]
    pub fn FPDF_LoadMemDocument(
        data_buf: *const ::std::os::raw::c_void,
        size: ::std::os::raw::c_int,
        password: FPDF_BYTESTRING,
    ) -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_LoadMemDocument64"]
    #[doc = "          Open and load a PDF document from memory."]
    #[doc = " Parameters:"]
    #[doc = "          data_buf    -   Pointer to a buffer containing the PDF document."]
    #[doc = "          size        -   Number of bytes in the PDF document."]
    #[doc = "          password    -   A string used as the password for the PDF file."]
    #[doc = "                          If no password is needed, empty or NULL can be used."]
    #[doc = " Return value:"]
    #[doc = "          A handle to the loaded document, or NULL on failure."]
    #[doc = " Comments:"]
    #[doc = "          The memory buffer must remain valid when the document is open."]
    #[doc = "          The loaded document can be closed by FPDF_CloseDocument."]
    #[doc = "          If this function fails, you can use FPDF_GetLastError() to retrieve"]
    #[doc = "          the reason why it failed."]
    #[doc = ""]
    #[doc = "          See the comments for FPDF_LoadDocument() regarding the encoding for"]
    #[doc = "          |password|."]
    #[doc = " Notes:"]
    #[doc = "          If PDFium is built with the XFA module, the application should call"]
    #[doc = "          FPDF_LoadXFA() function after the PDF document loaded to support XFA"]
    #[doc = "          fields defined in the fpdfformfill.h file."]
    pub fn FPDF_LoadMemDocument64(
        data_buf: *const ::std::os::raw::c_void,
        size: size_t,
        password: FPDF_BYTESTRING,
    ) -> FPDF_DOCUMENT;
}
#[doc = " Structure for custom file access."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_FILEACCESS {
    #[doc = " File length, in bytes."]
    pub m_FileLen: ::std::os::raw::c_ulong,
    #[doc = " A function pointer for getting a block of data from a specific position."]
    #[doc = " Position is specified by byte offset from the beginning of the file."]
    #[doc = " The pointer to the buffer is never NULL and the size is never 0."]
    #[doc = " The position and size will never go out of range of the file length."]
    #[doc = " It may be possible for FPDFSDK to call this function multiple times for"]
    #[doc = " the same position."]
    #[doc = " Return value: should be non-zero if successful, zero for error."]
    pub m_GetBlock: ::std::option::Option<
        unsafe extern "C" fn(
            param: *mut ::std::os::raw::c_void,
            position: ::std::os::raw::c_ulong,
            pBuf: *mut ::std::os::raw::c_uchar,
            size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A custom pointer for all implementation specific data.  This pointer will"]
    #[doc = " be used as the first parameter to the m_GetBlock callback."]
    pub m_Param: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FPDF_FILEACCESS() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_FILEACCESS>(),
        24usize,
        concat!("Size of: ", stringify!(FPDF_FILEACCESS))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_FILEACCESS>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_FILEACCESS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEACCESS>())).m_FileLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_FileLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEACCESS>())).m_GetBlock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_GetBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEACCESS>())).m_Param as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_Param)
        )
    );
}
#[doc = " Structure for file reading or writing (I/O)."]
#[doc = ""]
#[doc = " Note: This is a handler and should be implemented by callers,"]
#[doc = " and is only used from XFA."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_FILEHANDLER_ {
    #[doc = " User-defined data."]
    #[doc = " Note: Callers can use this field to track controls."]
    pub clientData: *mut ::std::os::raw::c_void,
    #[doc = " Callback function to release the current file stream object."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = " Returns:"]
    #[doc = "       None."]
    pub Release:
        ::std::option::Option<unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void)>,
    #[doc = " Callback function to retrieve the current file stream size."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = " Returns:"]
    #[doc = "       Size of file stream."]
    pub GetSize: ::std::option::Option<
        unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void) -> FPDF_DWORD,
    >,
    #[doc = " Callback function to read data from the current file stream."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = "       offset       -  Offset position starts from the beginning of file"]
    #[doc = "                       stream. This parameter indicates reading position."]
    #[doc = "       buffer       -  Memory buffer to store data which are read from"]
    #[doc = "                       file stream. This parameter should not be NULL."]
    #[doc = "       size         -  Size of data which should be read from file stream,"]
    #[doc = "                       in bytes. The buffer indicated by |buffer| must be"]
    #[doc = "                       large enough to store specified data."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub ReadBlock: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            offset: FPDF_DWORD,
            buffer: *mut ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to write data into the current file stream."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = "       offset       -  Offset position starts from the beginning of file"]
    #[doc = "                       stream. This parameter indicates writing position."]
    #[doc = "       buffer       -  Memory buffer contains data which is written into"]
    #[doc = "                       file stream. This parameter should not be NULL."]
    #[doc = "       size         -  Size of data which should be written into file"]
    #[doc = "                       stream, in bytes."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub WriteBlock: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            offset: FPDF_DWORD,
            buffer: *const ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to flush all internal accessing buffers."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub Flush: ::std::option::Option<
        unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to change file size."]
    #[doc = ""]
    #[doc = " Description:"]
    #[doc = "       This function is called under writing mode usually. Implementer"]
    #[doc = "       can determine whether to realize it based on application requests."]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = "       size         -  New size of file stream, in bytes."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub Truncate: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
}
#[test]
fn bindgen_test_layout_FPDF_FILEHANDLER_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_FILEHANDLER_>(),
        56usize,
        concat!("Size of: ", stringify!(FPDF_FILEHANDLER_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_FILEHANDLER_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_FILEHANDLER_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).clientData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(clientData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).Release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).GetSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(GetSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).ReadBlock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(ReadBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).WriteBlock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(WriteBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).Flush as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).Truncate as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Truncate)
        )
    );
}
#[doc = " Structure for file reading or writing (I/O)."]
#[doc = ""]
#[doc = " Note: This is a handler and should be implemented by callers,"]
#[doc = " and is only used from XFA."]
pub type FPDF_FILEHANDLER = FPDF_FILEHANDLER_;
extern "C" {
    #[doc = " Function: FPDF_LoadCustomDocument"]
    #[doc = "          Load PDF document from a custom access descriptor."]
    #[doc = " Parameters:"]
    #[doc = "          pFileAccess -   A structure for accessing the file."]
    #[doc = "          password    -   Optional password for decrypting the PDF file."]
    #[doc = " Return value:"]
    #[doc = "          A handle to the loaded document, or NULL on failure."]
    #[doc = " Comments:"]
    #[doc = "          The application must keep the file resources |pFileAccess| points to"]
    #[doc = "          valid until the returned FPDF_DOCUMENT is closed. |pFileAccess|"]
    #[doc = "          itself does not need to outlive the FPDF_DOCUMENT."]
    #[doc = ""]
    #[doc = "          The loaded document can be closed with FPDF_CloseDocument()."]
    #[doc = ""]
    #[doc = "          See the comments for FPDF_LoadDocument() regarding the encoding for"]
    #[doc = "          |password|."]
    #[doc = " Notes:"]
    #[doc = "          If PDFium is built with the XFA module, the application should call"]
    #[doc = "          FPDF_LoadXFA() function after the PDF document loaded to support XFA"]
    #[doc = "          fields defined in the fpdfformfill.h file."]
    pub fn FPDF_LoadCustomDocument(
        pFileAccess: *mut FPDF_FILEACCESS,
        password: FPDF_BYTESTRING,
    ) -> FPDF_DOCUMENT;
}
extern "C" {
    #[doc = " Function: FPDF_GetFileVersion"]
    #[doc = "          Get the file version of the given PDF document."]
    #[doc = " Parameters:"]
    #[doc = "          doc         -   Handle to a document."]
    #[doc = "          fileVersion -   The PDF file version. File version: 14 for 1.4, 15"]
    #[doc = "                          for 1.5, ..."]
    #[doc = " Return value:"]
    #[doc = "          True if succeeds, false otherwise."]
    #[doc = " Comments:"]
    #[doc = "          If the document was created by FPDF_CreateNewDocument,"]
    #[doc = "          then this function will always fail."]
    pub fn FPDF_GetFileVersion(
        doc: FPDF_DOCUMENT,
        fileVersion: *mut ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_GetLastError"]
    #[doc = "          Get last error code when a function fails."]
    #[doc = " Parameters:"]
    #[doc = "          None."]
    #[doc = " Return value:"]
    #[doc = "          A 32-bit integer indicating error code as defined above."]
    #[doc = " Comments:"]
    #[doc = "          If the previous SDK call succeeded, the return value of this"]
    #[doc = "          function is not defined."]
    pub fn FPDF_GetLastError() -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_DocumentHasValidCrossReferenceTable"]
    #[doc = "          Whether the document's cross reference table is valid or not."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to a document. Returned by FPDF_LoadDocument."]
    #[doc = " Return value:"]
    #[doc = "          True if the PDF parser did not encounter problems parsing the cross"]
    #[doc = "          reference table. False if the parser could not parse the cross"]
    #[doc = "          reference table and the table had to be rebuild from other data"]
    #[doc = "          within the document."]
    #[doc = " Comments:"]
    #[doc = "          The return value can change over time as the PDF parser evolves."]
    pub fn FPDF_DocumentHasValidCrossReferenceTable(document: FPDF_DOCUMENT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetTrailerEnds"]
    #[doc = "          Get the byte offsets of trailer ends."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to document. Returned by FPDF_LoadDocument()."]
    #[doc = "          buffer      -   The address of a buffer that receives the"]
    #[doc = "                          byte offsets."]
    #[doc = "          length      -   The size, in ints, of |buffer|."]
    #[doc = " Return value:"]
    #[doc = "          Returns the number of ints in the buffer on success, 0 on error."]
    #[doc = ""]
    #[doc = " |buffer| is an array of integers that describes the exact byte offsets of the"]
    #[doc = " trailer ends in the document. If |length| is less than the returned length,"]
    #[doc = " or |document| or |buffer| is NULL, |buffer| will not be modified."]
    pub fn FPDF_GetTrailerEnds(
        document: FPDF_DOCUMENT,
        buffer: *mut ::std::os::raw::c_uint,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_GetDocPermission"]
    #[doc = "          Get file permission flags of the document."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to a document. Returned by FPDF_LoadDocument."]
    #[doc = " Return value:"]
    #[doc = "          A 32-bit integer indicating permission flags. Please refer to the"]
    #[doc = "          PDF Reference for detailed descriptions. If the document is not"]
    #[doc = "          protected, 0xffffffff will be returned."]
    pub fn FPDF_GetDocPermissions(document: FPDF_DOCUMENT) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_GetSecurityHandlerRevision"]
    #[doc = "          Get the revision for the security handler."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to a document. Returned by FPDF_LoadDocument."]
    #[doc = " Return value:"]
    #[doc = "          The security handler revision number. Please refer to the PDF"]
    #[doc = "          Reference for a detailed description. If the document is not"]
    #[doc = "          protected, -1 will be returned."]
    pub fn FPDF_GetSecurityHandlerRevision(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageCount"]
    #[doc = "          Get total number of pages in the document."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to document. Returned by FPDF_LoadDocument."]
    #[doc = " Return value:"]
    #[doc = "          Total number of pages in the document."]
    pub fn FPDF_GetPageCount(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_LoadPage"]
    #[doc = "          Load a page inside the document."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to document. Returned by FPDF_LoadDocument"]
    #[doc = "          page_index  -   Index number of the page. 0 for the first page."]
    #[doc = " Return value:"]
    #[doc = "          A handle to the loaded page, or NULL if page load fails."]
    #[doc = " Comments:"]
    #[doc = "          The loaded page can be rendered to devices using FPDF_RenderPage."]
    #[doc = "          The loaded page can be closed using FPDF_ClosePage."]
    pub fn FPDF_LoadPage(document: FPDF_DOCUMENT, page_index: ::std::os::raw::c_int) -> FPDF_PAGE;
}
extern "C" {
    #[doc = " Experimental API"]
    #[doc = " Function: FPDF_GetPageWidthF"]
    #[doc = "          Get page width."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage()."]
    #[doc = " Return value:"]
    #[doc = "          Page width (excluding non-displayable area) measured in points."]
    #[doc = "          One point is 1/72 inch (around 0.3528 mm)."]
    pub fn FPDF_GetPageWidthF(page: FPDF_PAGE) -> f32;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageWidth"]
    #[doc = "          Get page width."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = " Return value:"]
    #[doc = "          Page width (excluding non-displayable area) measured in points."]
    #[doc = "          One point is 1/72 inch (around 0.3528 mm)."]
    #[doc = " Note:"]
    #[doc = "          Prefer FPDF_GetPageWidthF() above. This will be deprecated in the"]
    #[doc = "          future."]
    pub fn FPDF_GetPageWidth(page: FPDF_PAGE) -> f64;
}
extern "C" {
    #[doc = " Experimental API"]
    #[doc = " Function: FPDF_GetPageHeightF"]
    #[doc = "          Get page height."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage()."]
    #[doc = " Return value:"]
    #[doc = "          Page height (excluding non-displayable area) measured in points."]
    #[doc = "          One point is 1/72 inch (around 0.3528 mm)"]
    pub fn FPDF_GetPageHeightF(page: FPDF_PAGE) -> f32;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageHeight"]
    #[doc = "          Get page height."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = " Return value:"]
    #[doc = "          Page height (excluding non-displayable area) measured in points."]
    #[doc = "          One point is 1/72 inch (around 0.3528 mm)"]
    #[doc = " Note:"]
    #[doc = "          Prefer FPDF_GetPageHeightF() above. This will be deprecated in the"]
    #[doc = "          future."]
    pub fn FPDF_GetPageHeight(page: FPDF_PAGE) -> f64;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetPageBoundingBox"]
    #[doc = "          Get the bounding box of the page. This is the intersection between"]
    #[doc = "          its media box and its crop box."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = "          rect        -   Pointer to a rect to receive the page bounding box."]
    #[doc = "                          On an error, |rect| won't be filled."]
    #[doc = " Return value:"]
    #[doc = "          True for success."]
    pub fn FPDF_GetPageBoundingBox(page: FPDF_PAGE, rect: *mut FS_RECTF) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetPageSizeByIndexF"]
    #[doc = "          Get the size of the page at the given index."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to document. Returned by FPDF_LoadDocument()."]
    #[doc = "          page_index  -   Page index, zero for the first page."]
    #[doc = "          size        -   Pointer to a FS_SIZEF to receive the page size."]
    #[doc = "                          (in points)."]
    #[doc = " Return value:"]
    #[doc = "          Non-zero for success. 0 for error (document or page not found)."]
    pub fn FPDF_GetPageSizeByIndexF(
        document: FPDF_DOCUMENT,
        page_index: ::std::os::raw::c_int,
        size: *mut FS_SIZEF,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_GetPageSizeByIndex"]
    #[doc = "          Get the size of the page at the given index."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to document. Returned by FPDF_LoadDocument."]
    #[doc = "          page_index  -   Page index, zero for the first page."]
    #[doc = "          width       -   Pointer to a double to receive the page width"]
    #[doc = "                          (in points)."]
    #[doc = "          height      -   Pointer to a double to receive the page height"]
    #[doc = "                          (in points)."]
    #[doc = " Return value:"]
    #[doc = "          Non-zero for success. 0 for error (document or page not found)."]
    #[doc = " Note:"]
    #[doc = "          Prefer FPDF_GetPageSizeByIndexF() above. This will be deprecated in"]
    #[doc = "          the future."]
    pub fn FPDF_GetPageSizeByIndex(
        document: FPDF_DOCUMENT,
        page_index: ::std::os::raw::c_int,
        width: *mut f64,
        height: *mut f64,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Struct for color scheme."]
#[doc = " Each should be a 32-bit value specifying the color, in 8888 ARGB format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_COLORSCHEME_ {
    pub path_fill_color: FPDF_DWORD,
    pub path_stroke_color: FPDF_DWORD,
    pub text_fill_color: FPDF_DWORD,
    pub text_stroke_color: FPDF_DWORD,
}
#[test]
fn bindgen_test_layout_FPDF_COLORSCHEME_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_COLORSCHEME_>(),
        32usize,
        concat!("Size of: ", stringify!(FPDF_COLORSCHEME_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_COLORSCHEME_>(),
        8usize,
        concat!("Alignment of ", stringify!(FPDF_COLORSCHEME_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).path_fill_color as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(path_fill_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).path_stroke_color as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(path_stroke_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).text_fill_color as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(text_fill_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).text_stroke_color as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(text_stroke_color)
        )
    );
}
#[doc = " Struct for color scheme."]
#[doc = " Each should be a 32-bit value specifying the color, in 8888 ARGB format."]
pub type FPDF_COLORSCHEME = FPDF_COLORSCHEME_;
extern "C" {
    #[doc = " Function: FPDF_RenderPageBitmap"]
    #[doc = "          Render contents of a page to a device independent bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the device independent bitmap (as the"]
    #[doc = "                          output buffer). The bitmap handle can be created"]
    #[doc = "                          by FPDFBitmap_Create or retrieved from an image"]
    #[doc = "                          object by FPDFImageObj_GetBitmap."]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage"]
    #[doc = "          start_x     -   Left pixel position of the display area in"]
    #[doc = "                          bitmap coordinates."]
    #[doc = "          start_y     -   Top pixel position of the display area in bitmap"]
    #[doc = "                          coordinates."]
    #[doc = "          size_x      -   Horizontal size (in pixels) for displaying the page."]
    #[doc = "          size_y      -   Vertical size (in pixels) for displaying the page."]
    #[doc = "          rotate      -   Page orientation:"]
    #[doc = "                            0 (normal)"]
    #[doc = "                            1 (rotated 90 degrees clockwise)"]
    #[doc = "                            2 (rotated 180 degrees)"]
    #[doc = "                            3 (rotated 90 degrees counter-clockwise)"]
    #[doc = "          flags       -   0 for normal display, or combination of the Page"]
    #[doc = "                          Rendering flags defined above. With the FPDF_ANNOT"]
    #[doc = "                          flag, it renders all annotations that do not require"]
    #[doc = "                          user-interaction, which are all annotations except"]
    #[doc = "                          widget and popup annotations."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    pub fn FPDF_RenderPageBitmap(
        bitmap: FPDF_BITMAP,
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Function: FPDF_RenderPageBitmapWithMatrix"]
    #[doc = "          Render contents of a page to a device independent bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the device independent bitmap (as the"]
    #[doc = "                          output buffer). The bitmap handle can be created"]
    #[doc = "                          by FPDFBitmap_Create or retrieved by"]
    #[doc = "                          FPDFImageObj_GetBitmap."]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = "          matrix      -   The transform matrix, which must be invertible."]
    #[doc = "                          See PDF Reference 1.7, 4.2.2 Common Transformations."]
    #[doc = "          clipping    -   The rect to clip to in device coords."]
    #[doc = "          flags       -   0 for normal display, or combination of the Page"]
    #[doc = "                          Rendering flags defined above. With the FPDF_ANNOT"]
    #[doc = "                          flag, it renders all annotations that do not require"]
    #[doc = "                          user-interaction, which are all annotations except"]
    #[doc = "                          widget and popup annotations."]
    #[doc = " Return value:"]
    #[doc = "          None. Note that behavior is undefined if det of |matrix| is 0."]
    pub fn FPDF_RenderPageBitmapWithMatrix(
        bitmap: FPDF_BITMAP,
        page: FPDF_PAGE,
        matrix: *const FS_MATRIX,
        clipping: *const FS_RECTF,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Function: FPDF_ClosePage"]
    #[doc = "          Close a loaded PDF page."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the loaded page."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    pub fn FPDF_ClosePage(page: FPDF_PAGE);
}
extern "C" {
    #[doc = " Function: FPDF_CloseDocument"]
    #[doc = "          Close a loaded PDF document."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    pub fn FPDF_CloseDocument(document: FPDF_DOCUMENT);
}
extern "C" {
    #[doc = " Function: FPDF_DeviceToPage"]
    #[doc = "          Convert the screen coordinates of a point to page coordinates."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = "          start_x     -   Left pixel position of the display area in"]
    #[doc = "                          device coordinates."]
    #[doc = "          start_y     -   Top pixel position of the display area in device"]
    #[doc = "                          coordinates."]
    #[doc = "          size_x      -   Horizontal size (in pixels) for displaying the page."]
    #[doc = "          size_y      -   Vertical size (in pixels) for displaying the page."]
    #[doc = "          rotate      -   Page orientation:"]
    #[doc = "                            0 (normal)"]
    #[doc = "                            1 (rotated 90 degrees clockwise)"]
    #[doc = "                            2 (rotated 180 degrees)"]
    #[doc = "                            3 (rotated 90 degrees counter-clockwise)"]
    #[doc = "          device_x    -   X value in device coordinates to be converted."]
    #[doc = "          device_y    -   Y value in device coordinates to be converted."]
    #[doc = "          page_x      -   A pointer to a double receiving the converted X"]
    #[doc = "                          value in page coordinates."]
    #[doc = "          page_y      -   A pointer to a double receiving the converted Y"]
    #[doc = "                          value in page coordinates."]
    #[doc = " Return value:"]
    #[doc = "          Returns true if the conversion succeeds, and |page_x| and |page_y|"]
    #[doc = "          successfully receives the converted coordinates."]
    #[doc = " Comments:"]
    #[doc = "          The page coordinate system has its origin at the left-bottom corner"]
    #[doc = "          of the page, with the X-axis on the bottom going to the right, and"]
    #[doc = "          the Y-axis on the left side going up."]
    #[doc = ""]
    #[doc = "          NOTE: this coordinate system can be altered when you zoom, scroll,"]
    #[doc = "          or rotate a page, however, a point on the page should always have"]
    #[doc = "          the same coordinate values in the page coordinate system."]
    #[doc = ""]
    #[doc = "          The device coordinate system is device dependent. For screen device,"]
    #[doc = "          its origin is at the left-top corner of the window. However this"]
    #[doc = "          origin can be altered by the Windows coordinate transformation"]
    #[doc = "          utilities."]
    #[doc = ""]
    #[doc = "          You must make sure the start_x, start_y, size_x, size_y"]
    #[doc = "          and rotate parameters have exactly same values as you used in"]
    #[doc = "          the FPDF_RenderPage() function call."]
    pub fn FPDF_DeviceToPage(
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        device_x: ::std::os::raw::c_int,
        device_y: ::std::os::raw::c_int,
        page_x: *mut f64,
        page_y: *mut f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_PageToDevice"]
    #[doc = "          Convert the page coordinates of a point to screen coordinates."]
    #[doc = " Parameters:"]
    #[doc = "          page        -   Handle to the page. Returned by FPDF_LoadPage."]
    #[doc = "          start_x     -   Left pixel position of the display area in"]
    #[doc = "                          device coordinates."]
    #[doc = "          start_y     -   Top pixel position of the display area in device"]
    #[doc = "                          coordinates."]
    #[doc = "          size_x      -   Horizontal size (in pixels) for displaying the page."]
    #[doc = "          size_y      -   Vertical size (in pixels) for displaying the page."]
    #[doc = "          rotate      -   Page orientation:"]
    #[doc = "                            0 (normal)"]
    #[doc = "                            1 (rotated 90 degrees clockwise)"]
    #[doc = "                            2 (rotated 180 degrees)"]
    #[doc = "                            3 (rotated 90 degrees counter-clockwise)"]
    #[doc = "          page_x      -   X value in page coordinates."]
    #[doc = "          page_y      -   Y value in page coordinate."]
    #[doc = "          device_x    -   A pointer to an integer receiving the result X"]
    #[doc = "                          value in device coordinates."]
    #[doc = "          device_y    -   A pointer to an integer receiving the result Y"]
    #[doc = "                          value in device coordinates."]
    #[doc = " Return value:"]
    #[doc = "          Returns true if the conversion succeeds, and |device_x| and"]
    #[doc = "          |device_y| successfully receives the converted coordinates."]
    #[doc = " Comments:"]
    #[doc = "          See comments for FPDF_DeviceToPage()."]
    pub fn FPDF_PageToDevice(
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
        device_x: *mut ::std::os::raw::c_int,
        device_y: *mut ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_Create"]
    #[doc = "          Create a device independent bitmap (FXDIB)."]
    #[doc = " Parameters:"]
    #[doc = "          width       -   The number of pixels in width for the bitmap."]
    #[doc = "                          Must be greater than 0."]
    #[doc = "          height      -   The number of pixels in height for the bitmap."]
    #[doc = "                          Must be greater than 0."]
    #[doc = "          alpha       -   A flag indicating whether the alpha channel is used."]
    #[doc = "                          Non-zero for using alpha, zero for not using."]
    #[doc = " Return value:"]
    #[doc = "          The created bitmap handle, or NULL if a parameter error or out of"]
    #[doc = "          memory."]
    #[doc = " Comments:"]
    #[doc = "          The bitmap always uses 4 bytes per pixel. The first byte is always"]
    #[doc = "          double word aligned."]
    #[doc = ""]
    #[doc = "          The byte order is BGRx (the last byte unused if no alpha channel) or"]
    #[doc = "          BGRA."]
    #[doc = ""]
    #[doc = "          The pixels in a horizontal line are stored side by side, with the"]
    #[doc = "          left most pixel stored first (with lower memory address)."]
    #[doc = "          Each line uses width * 4 bytes."]
    #[doc = ""]
    #[doc = "          Lines are stored one after another, with the top most line stored"]
    #[doc = "          first. There is no gap between adjacent lines."]
    #[doc = ""]
    #[doc = "          This function allocates enough memory for holding all pixels in the"]
    #[doc = "          bitmap, but it doesn't initialize the buffer. Applications can use"]
    #[doc = "          FPDFBitmap_FillRect() to fill the bitmap using any color. If the OS"]
    #[doc = "          allows it, this function can allocate up to 4 GB of memory."]
    pub fn FPDFBitmap_Create(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        alpha: ::std::os::raw::c_int,
    ) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_CreateEx"]
    #[doc = "          Create a device independent bitmap (FXDIB)"]
    #[doc = " Parameters:"]
    #[doc = "          width       -   The number of pixels in width for the bitmap."]
    #[doc = "                          Must be greater than 0."]
    #[doc = "          height      -   The number of pixels in height for the bitmap."]
    #[doc = "                          Must be greater than 0."]
    #[doc = "          format      -   A number indicating for bitmap format, as defined"]
    #[doc = "                          above."]
    #[doc = "          first_scan  -   A pointer to the first byte of the first line if"]
    #[doc = "                          using an external buffer. If this parameter is NULL,"]
    #[doc = "                          then the a new buffer will be created."]
    #[doc = "          stride      -   Number of bytes for each scan line, for external"]
    #[doc = "                          buffer only."]
    #[doc = " Return value:"]
    #[doc = "          The bitmap handle, or NULL if parameter error or out of memory."]
    #[doc = " Comments:"]
    #[doc = "          Similar to FPDFBitmap_Create function, but allows for more formats"]
    #[doc = "          and an external buffer is supported. The bitmap created by this"]
    #[doc = "          function can be used in any place that a FPDF_BITMAP handle is"]
    #[doc = "          required."]
    #[doc = ""]
    #[doc = "          If an external buffer is used, then the application should destroy"]
    #[doc = "          the buffer by itself. FPDFBitmap_Destroy function will not destroy"]
    #[doc = "          the buffer."]
    pub fn FPDFBitmap_CreateEx(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        format: ::std::os::raw::c_int,
        first_scan: *mut ::std::os::raw::c_void,
        stride: ::std::os::raw::c_int,
    ) -> FPDF_BITMAP;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetFormat"]
    #[doc = "          Get the format of the bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          The format of the bitmap."]
    #[doc = " Comments:"]
    #[doc = "          Only formats supported by FPDFBitmap_CreateEx are supported by this"]
    #[doc = "          function; see the list of such formats above."]
    pub fn FPDFBitmap_GetFormat(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_FillRect"]
    #[doc = "          Fill a rectangle in a bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   The handle to the bitmap. Returned by"]
    #[doc = "                          FPDFBitmap_Create."]
    #[doc = "          left        -   The left position. Starting from 0 at the"]
    #[doc = "                          left-most pixel."]
    #[doc = "          top         -   The top position. Starting from 0 at the"]
    #[doc = "                          top-most line."]
    #[doc = "          width       -   Width in pixels to be filled."]
    #[doc = "          height      -   Height in pixels to be filled."]
    #[doc = "          color       -   A 32-bit value specifing the color, in 8888 ARGB"]
    #[doc = "                          format."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    #[doc = " Comments:"]
    #[doc = "          This function sets the color and (optionally) alpha value in the"]
    #[doc = "          specified region of the bitmap."]
    #[doc = ""]
    #[doc = "          NOTE: If the alpha channel is used, this function does NOT"]
    #[doc = "          composite the background with the source color, instead the"]
    #[doc = "          background will be replaced by the source color and the alpha."]
    #[doc = ""]
    #[doc = "          If the alpha channel is not used, the alpha parameter is ignored."]
    pub fn FPDFBitmap_FillRect(
        bitmap: FPDF_BITMAP,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        color: FPDF_DWORD,
    );
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetBuffer"]
    #[doc = "          Get data buffer of a bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          The pointer to the first byte of the bitmap buffer."]
    #[doc = " Comments:"]
    #[doc = "          The stride may be more than width * number of bytes per pixel"]
    #[doc = ""]
    #[doc = "          Applications can use this function to get the bitmap buffer pointer,"]
    #[doc = "          then manipulate any color and/or alpha values for any pixels in the"]
    #[doc = "          bitmap."]
    #[doc = ""]
    #[doc = "          The data is in BGRA format. Where the A maybe unused if alpha was"]
    #[doc = "          not specified."]
    pub fn FPDFBitmap_GetBuffer(bitmap: FPDF_BITMAP) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetWidth"]
    #[doc = "          Get width of a bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          The width of the bitmap in pixels."]
    pub fn FPDFBitmap_GetWidth(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetHeight"]
    #[doc = "          Get height of a bitmap."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          The height of the bitmap in pixels."]
    pub fn FPDFBitmap_GetHeight(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_GetStride"]
    #[doc = "          Get number of bytes for each line in the bitmap buffer."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          The number of bytes for each line in the bitmap buffer."]
    #[doc = " Comments:"]
    #[doc = "          The stride may be more than width * number of bytes per pixel."]
    pub fn FPDFBitmap_GetStride(bitmap: FPDF_BITMAP) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFBitmap_Destroy"]
    #[doc = "          Destroy a bitmap and release all related buffers."]
    #[doc = " Parameters:"]
    #[doc = "          bitmap      -   Handle to the bitmap. Returned by FPDFBitmap_Create"]
    #[doc = "                          or FPDFImageObj_GetBitmap."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    #[doc = " Comments:"]
    #[doc = "          This function will not destroy any external buffers provided when"]
    #[doc = "          the bitmap was created."]
    pub fn FPDFBitmap_Destroy(bitmap: FPDF_BITMAP);
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetPrintScaling"]
    #[doc = "          Whether the PDF document prefers to be scaled or not."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = " Return value:"]
    #[doc = "          None."]
    pub fn FPDF_VIEWERREF_GetPrintScaling(document: FPDF_DOCUMENT) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetNumCopies"]
    #[doc = "          Returns the number of copies to be printed."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = " Return value:"]
    #[doc = "          The number of copies to be printed."]
    pub fn FPDF_VIEWERREF_GetNumCopies(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetPrintPageRange"]
    #[doc = "          Page numbers to initialize print dialog box when file is printed."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = " Return value:"]
    #[doc = "          The print page range to be used for printing."]
    pub fn FPDF_VIEWERREF_GetPrintPageRange(document: FPDF_DOCUMENT) -> FPDF_PAGERANGE;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_VIEWERREF_GetPrintPageRangeCount"]
    #[doc = "          Returns the number of elements in a FPDF_PAGERANGE."]
    #[doc = " Parameters:"]
    #[doc = "          pagerange   -   Handle to the page range."]
    #[doc = " Return value:"]
    #[doc = "          The number of elements in the page range. Returns 0 on error."]
    pub fn FPDF_VIEWERREF_GetPrintPageRangeCount(pagerange: FPDF_PAGERANGE) -> size_t;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_VIEWERREF_GetPrintPageRangeElement"]
    #[doc = "          Returns an element from a FPDF_PAGERANGE."]
    #[doc = " Parameters:"]
    #[doc = "          pagerange   -   Handle to the page range."]
    #[doc = "          index       -   Index of the element."]
    #[doc = " Return value:"]
    #[doc = "          The value of the element in the page range at a given index."]
    #[doc = "          Returns -1 on error."]
    pub fn FPDF_VIEWERREF_GetPrintPageRangeElement(
        pagerange: FPDF_PAGERANGE,
        index: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetDuplex"]
    #[doc = "          Returns the paper handling option to be used when printing from"]
    #[doc = "          the print dialog."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = " Return value:"]
    #[doc = "          The paper handling option to be used when printing."]
    pub fn FPDF_VIEWERREF_GetDuplex(document: FPDF_DOCUMENT) -> FPDF_DUPLEXTYPE;
}
extern "C" {
    #[doc = " Function: FPDF_VIEWERREF_GetName"]
    #[doc = "          Gets the contents for a viewer ref, with a given key. The value must"]
    #[doc = "          be of type \"name\"."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = "          key         -   Name of the key in the viewer pref dictionary,"]
    #[doc = "                          encoded in UTF-8."]
    #[doc = "          buffer      -   A string to write the contents of the key to."]
    #[doc = "          length      -   Length of the buffer."]
    #[doc = " Return value:"]
    #[doc = "          The number of bytes in the contents, including the NULL terminator."]
    #[doc = "          Thus if the return value is 0, then that indicates an error, such"]
    #[doc = "          as when |document| is invalid or |buffer| is NULL. If |length| is"]
    #[doc = "          less than the returned length, or |buffer| is NULL, |buffer| will"]
    #[doc = "          not be modified."]
    pub fn FPDF_VIEWERREF_GetName(
        document: FPDF_DOCUMENT,
        key: FPDF_BYTESTRING,
        buffer: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FPDF_CountNamedDests"]
    #[doc = "          Get the count of named destinations in the PDF document."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to a document"]
    #[doc = " Return value:"]
    #[doc = "          The count of named destinations."]
    pub fn FPDF_CountNamedDests(document: FPDF_DOCUMENT) -> FPDF_DWORD;
}
extern "C" {
    #[doc = " Function: FPDF_GetNamedDestByName"]
    #[doc = "          Get a the destination handle for the given name."]
    #[doc = " Parameters:"]
    #[doc = "          document    -   Handle to the loaded document."]
    #[doc = "          name        -   The name of a destination."]
    #[doc = " Return value:"]
    #[doc = "          The handle to the destination."]
    pub fn FPDF_GetNamedDestByName(document: FPDF_DOCUMENT, name: FPDF_BYTESTRING) -> FPDF_DEST;
}
extern "C" {
    #[doc = " Function: FPDF_GetNamedDest"]
    #[doc = "          Get the named destination by index."]
    #[doc = " Parameters:"]
    #[doc = "          document        -   Handle to a document"]
    #[doc = "          index           -   The index of a named destination."]
    #[doc = "          buffer          -   The buffer to store the destination name,"]
    #[doc = "                              used as wchar_t*."]
    #[doc = "          buflen [in/out] -   Size of the buffer in bytes on input,"]
    #[doc = "                              length of the result in bytes on output"]
    #[doc = "                              or -1 if the buffer is too small."]
    #[doc = " Return value:"]
    #[doc = "          The destination handle for a given index, or NULL if there is no"]
    #[doc = "          named destination corresponding to |index|."]
    #[doc = " Comments:"]
    #[doc = "          Call this function twice to get the name of the named destination:"]
    #[doc = "            1) First time pass in |buffer| as NULL and get buflen."]
    #[doc = "            2) Second time pass in allocated |buffer| and buflen to retrieve"]
    #[doc = "               |buffer|, which should be used as wchar_t*."]
    #[doc = ""]
    #[doc = "         If buflen is not sufficiently large, it will be set to -1 upon"]
    #[doc = "         return."]
    pub fn FPDF_GetNamedDest(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: *mut ::std::os::raw::c_long,
    ) -> FPDF_DEST;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetXFAPacketCount"]
    #[doc = "          Get the number of valid packets in the XFA entry."]
    #[doc = " Parameters:"]
    #[doc = "          document - Handle to the document."]
    #[doc = " Return value:"]
    #[doc = "          The number of valid packets, or -1 on error."]
    pub fn FPDF_GetXFAPacketCount(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetXFAPacketName"]
    #[doc = "          Get the name of a packet in the XFA array."]
    #[doc = " Parameters:"]
    #[doc = "          document - Handle to the document."]
    #[doc = "          index    - Index number of the packet. 0 for the first packet."]
    #[doc = "          buffer   - Buffer for holding the name of the XFA packet."]
    #[doc = "          buflen   - Length of |buffer| in bytes."]
    #[doc = " Return value:"]
    #[doc = "          The length of the packet name in bytes, or 0 on error."]
    #[doc = ""]
    #[doc = " |document| must be valid and |index| must be in the range [0, N), where N is"]
    #[doc = " the value returned by FPDF_GetXFAPacketCount()."]
    #[doc = " |buffer| is only modified if it is non-NULL and |buflen| is greater than or"]
    #[doc = " equal to the length of the packet name. The packet name includes a"]
    #[doc = " terminating NUL character. |buffer| is unmodified on error."]
    pub fn FPDF_GetXFAPacketName(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FPDF_GetXFAPacketContent"]
    #[doc = "          Get the content of a packet in the XFA array."]
    #[doc = " Parameters:"]
    #[doc = "          document   - Handle to the document."]
    #[doc = "          index      - Index number of the packet. 0 for the first packet."]
    #[doc = "          buffer     - Buffer for holding the content of the XFA packet."]
    #[doc = "          buflen     - Length of |buffer| in bytes."]
    #[doc = "          out_buflen - Pointer to the variable that will receive the minimum"]
    #[doc = "                       buffer size needed to contain the content of the XFA"]
    #[doc = "                       packet."]
    #[doc = " Return value:"]
    #[doc = "          Whether the operation succeeded or not."]
    #[doc = ""]
    #[doc = " |document| must be valid and |index| must be in the range [0, N), where N is"]
    #[doc = " the value returned by FPDF_GetXFAPacketCount(). |out_buflen| must not be"]
    #[doc = " NULL. When the aforementioned arguments are valid, the operation succeeds,"]
    #[doc = " and |out_buflen| receives the content size. |buffer| is only modified if"]
    #[doc = " |buffer| is non-null and long enough to contain the content. Callers must"]
    #[doc = " check both the return value and the input |buflen| is no less than the"]
    #[doc = " returned |out_buflen| before using the data in |buffer|."]
    pub fn FPDF_GetXFAPacketContent(
        document: FPDF_DOCUMENT,
        index: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
        out_buflen: *mut ::std::os::raw::c_ulong,
    ) -> FPDF_BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPDF_JsPlatform {
    #[doc = " Version number of the interface. Currently must be 2."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Method: app_alert"]
    #[doc = "       Pop up a dialog to show warning or hint."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       Msg         -   A string containing the message to be displayed."]
    #[doc = "       Title       -   The title of the dialog."]
    #[doc = "       Type        -   The type of button group, one of the"]
    #[doc = "                       JSPLATFORM_ALERT_BUTTON_* values above."]
    #[doc = "       nIcon       -   The type of the icon, one of the"]
    #[doc = "                       JSPLATFORM_ALERT_ICON_* above."]
    #[doc = " Return Value:"]
    #[doc = "       Option selected by user in dialogue, one of the"]
    #[doc = "       JSPLATFORM_ALERT_RETURN_* values above."]
    pub app_alert: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            Msg: FPDF_WIDESTRING,
            Title: FPDF_WIDESTRING,
            Type: ::std::os::raw::c_int,
            Icon: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: app_beep"]
    #[doc = "       Causes the system to play a sound."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       nType       -   The sound type, see JSPLATFORM_BEEP_TYPE_*"]
    #[doc = "                       above."]
    #[doc = " Return Value:"]
    #[doc = "       None"]
    pub app_beep: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _IPDF_JsPlatform, nType: ::std::os::raw::c_int),
    >,
    #[doc = " Method: app_response"]
    #[doc = "       Displays a dialog box containing a question and an entry field for"]
    #[doc = "       the user to reply to the question."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       Question    -   The question to be posed to the user."]
    #[doc = "       Title       -   The title of the dialog box."]
    #[doc = "       Default     -   A default value for the answer to the question. If"]
    #[doc = "                       not specified, no default value is presented."]
    #[doc = "       cLabel      -   A short string to appear in front of and on the"]
    #[doc = "                       same line as the edit text field."]
    #[doc = "       bPassword   -   If true, indicates that the user's response should"]
    #[doc = "                       be shown as asterisks (*) or bullets (?) to mask"]
    #[doc = "                       the response, which might be sensitive information."]
    #[doc = "       response    -   A string buffer allocated by PDFium, to receive the"]
    #[doc = "                       user's response."]
    #[doc = "       length      -   The length of the buffer in bytes. Currently, it is"]
    #[doc = "                       always 2048."]
    #[doc = " Return Value:"]
    #[doc = "       Number of bytes the complete user input would actually require, not"]
    #[doc = "       including trailing zeros, regardless of the value of the length"]
    #[doc = "       parameter or the presence of the response buffer."]
    #[doc = " Comments:"]
    #[doc = "       No matter on what platform, the response buffer should be always"]
    #[doc = "       written using UTF-16LE encoding. If a response buffer is"]
    #[doc = "       present and the size of the user input exceeds the capacity of the"]
    #[doc = "       buffer as specified by the length parameter, only the"]
    #[doc = "       first \"length\" bytes of the user input are to be written to the"]
    #[doc = "       buffer."]
    pub app_response: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            Question: FPDF_WIDESTRING,
            Title: FPDF_WIDESTRING,
            Default: FPDF_WIDESTRING,
            cLabel: FPDF_WIDESTRING,
            bPassword: FPDF_BOOL,
            response: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: Doc_getFilePath"]
    #[doc = "       Get the file path of the current document."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       filePath    -   The string buffer to receive the file path. Can"]
    #[doc = "                       be NULL."]
    #[doc = "       length      -   The length of the buffer, number of bytes. Can"]
    #[doc = "                       be 0."]
    #[doc = " Return Value:"]
    #[doc = "       Number of bytes the filePath consumes, including trailing zeros."]
    #[doc = " Comments:"]
    #[doc = "       The filePath should always be provided in the local encoding."]
    #[doc = "       The return value always indicated number of bytes required for"]
    #[doc = "       the buffer, even when there is no buffer specified, or the buffer"]
    #[doc = "       size is less than required. In this case, the buffer will not"]
    #[doc = "       be modified."]
    pub Doc_getFilePath: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            filePath: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: Doc_mail"]
    #[doc = "       Mails the data buffer as an attachment to all recipients, with or"]
    #[doc = "       without user interaction."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       mailData    -   Pointer to the data buffer to be sent. Can be NULL."]
    #[doc = "       length      -   The size,in bytes, of the buffer pointed by"]
    #[doc = "                       mailData parameter. Can be 0."]
    #[doc = "       bUI         -   If true, the rest of the parameters are used in a"]
    #[doc = "                       compose-new-message window that is displayed to the"]
    #[doc = "                       user. If false, the cTo parameter is required and"]
    #[doc = "                       all others are optional."]
    #[doc = "       To          -   A semicolon-delimited list of recipients for the"]
    #[doc = "                       message."]
    #[doc = "       Subject     -   The subject of the message. The length limit is"]
    #[doc = "                       64 KB."]
    #[doc = "       CC          -   A semicolon-delimited list of CC recipients for"]
    #[doc = "                       the message."]
    #[doc = "       BCC         -   A semicolon-delimited list of BCC recipients for"]
    #[doc = "                       the message."]
    #[doc = "       Msg         -   The content of the message. The length limit is"]
    #[doc = "                       64 KB."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       If the parameter mailData is NULL or length is 0, the current"]
    #[doc = "       document will be mailed as an attachment to all recipients."]
    pub Doc_mail: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            mailData: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
            bUI: FPDF_BOOL,
            To: FPDF_WIDESTRING,
            Subject: FPDF_WIDESTRING,
            CC: FPDF_WIDESTRING,
            BCC: FPDF_WIDESTRING,
            Msg: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: Doc_print"]
    #[doc = "       Prints all or a specific number of pages of the document."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis         -   Pointer to the interface structure itself."]
    #[doc = "       bUI           -   If true, will cause a UI to be presented to the"]
    #[doc = "                         user to obtain printing information and confirm"]
    #[doc = "                         the action."]
    #[doc = "       nStart        -   A 0-based index that defines the start of an"]
    #[doc = "                         inclusive range of pages."]
    #[doc = "       nEnd          -   A 0-based index that defines the end of an"]
    #[doc = "                         inclusive page range."]
    #[doc = "       bSilent       -   If true, suppresses the cancel dialog box while"]
    #[doc = "                         the document is printing. The default is false."]
    #[doc = "       bShrinkToFit  -   If true, the page is shrunk (if necessary) to"]
    #[doc = "                         fit within the imageable area of the printed page."]
    #[doc = "       bPrintAsImage -   If true, print pages as an image."]
    #[doc = "       bReverse      -   If true, print from nEnd to nStart."]
    #[doc = "       bAnnotations  -   If true (the default), annotations are"]
    #[doc = "                         printed."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    pub Doc_print: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            bUI: FPDF_BOOL,
            nStart: ::std::os::raw::c_int,
            nEnd: ::std::os::raw::c_int,
            bSilent: FPDF_BOOL,
            bShrinkToFit: FPDF_BOOL,
            bPrintAsImage: FPDF_BOOL,
            bReverse: FPDF_BOOL,
            bAnnotations: FPDF_BOOL,
        ),
    >,
    #[doc = " Method: Doc_submitForm"]
    #[doc = "       Send the form data to a specified URL."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       formData    -   Pointer to the data buffer to be sent."]
    #[doc = "       length      -   The size,in bytes, of the buffer pointed by"]
    #[doc = "                       formData parameter."]
    #[doc = "       URL         -   The URL to send to."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    pub Doc_submitForm: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            formData: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
            URL: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: Doc_gotoPage"]
    #[doc = "       Jump to a specified page."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       nPageNum    -   The specified page number, zero for the first page."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = ""]
    pub Doc_gotoPage: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _IPDF_JsPlatform, nPageNum: ::std::os::raw::c_int),
    >,
    #[doc = " Method: Field_browse"]
    #[doc = "       Show a file selection dialog, and return the selected file path."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       filePath    -   Pointer to the data buffer to receive the file"]
    #[doc = "                       path. Can be NULL."]
    #[doc = "       length      -   The length of the buffer, in bytes. Can be 0."]
    #[doc = " Return Value:"]
    #[doc = "       Number of bytes the filePath consumes, including trailing zeros."]
    #[doc = " Comments:"]
    #[doc = "       The filePath shoule always be provided in local encoding."]
    pub Field_browse: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            filePath: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Pointer to FPDF_FORMFILLINFO interface."]
    pub m_pFormfillinfo: *mut ::std::os::raw::c_void,
    #[doc = " Unused in v3, retain for compatibility."]
    pub m_isolate: *mut ::std::os::raw::c_void,
    #[doc = " Unused in v3, retain for compatibility."]
    pub m_v8EmbedderSlot: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__IPDF_JsPlatform() {
    assert_eq!(
        ::std::mem::size_of::<_IPDF_JsPlatform>(),
        104usize,
        concat!("Size of: ", stringify!(_IPDF_JsPlatform))
    );
    assert_eq!(
        ::std::mem::align_of::<_IPDF_JsPlatform>(),
        8usize,
        concat!("Alignment of ", stringify!(_IPDF_JsPlatform))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).app_alert as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(app_alert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).app_beep as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(app_beep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).app_response as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(app_response)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Doc_getFilePath as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_getFilePath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Doc_mail as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_mail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Doc_print as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_print)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Doc_submitForm as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_submitForm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Doc_gotoPage as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_gotoPage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Field_browse as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Field_browse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IPDF_JsPlatform>())).m_pFormfillinfo as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(m_pFormfillinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).m_isolate as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(m_isolate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IPDF_JsPlatform>())).m_v8EmbedderSlot as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(m_v8EmbedderSlot)
        )
    );
}
pub type IPDF_JSPLATFORM = _IPDF_JsPlatform;
#[doc = " Function signature for the callback function passed to the FFI_SetTimer"]
#[doc = " method."]
#[doc = " Parameters:"]
#[doc = "          idEvent     -   Identifier of the timer."]
#[doc = " Return value:"]
#[doc = "          None."]
pub type TimerCallback =
    ::std::option::Option<unsafe extern "C" fn(idEvent: ::std::os::raw::c_int)>;
#[doc = " Declares of a struct type to the local system time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPDF_SYSTEMTIME {
    #[doc = " years since 1900"]
    pub wYear: ::std::os::raw::c_ushort,
    #[doc = " months since January - [0,11]"]
    pub wMonth: ::std::os::raw::c_ushort,
    #[doc = " days since Sunday - [0,6]"]
    pub wDayOfWeek: ::std::os::raw::c_ushort,
    #[doc = " day of the month - [1,31]"]
    pub wDay: ::std::os::raw::c_ushort,
    #[doc = " hours since midnight - [0,23]"]
    pub wHour: ::std::os::raw::c_ushort,
    #[doc = " minutes after the hour - [0,59]"]
    pub wMinute: ::std::os::raw::c_ushort,
    #[doc = " seconds after the minute - [0,59]"]
    pub wSecond: ::std::os::raw::c_ushort,
    #[doc = " milliseconds after the second - [0,999]"]
    pub wMilliseconds: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__FPDF_SYSTEMTIME() {
    assert_eq!(
        ::std::mem::size_of::<_FPDF_SYSTEMTIME>(),
        16usize,
        concat!("Size of: ", stringify!(_FPDF_SYSTEMTIME))
    );
    assert_eq!(
        ::std::mem::align_of::<_FPDF_SYSTEMTIME>(),
        2usize,
        concat!("Alignment of ", stringify!(_FPDF_SYSTEMTIME))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wYear as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wYear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wMonth as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wMonth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wDayOfWeek as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wDayOfWeek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wDay as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wDay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wHour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wHour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wMinute as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wMinute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wSecond as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wSecond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wMilliseconds as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wMilliseconds)
        )
    );
}
#[doc = " Declares of a struct type to the local system time."]
pub type FPDF_SYSTEMTIME = _FPDF_SYSTEMTIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPDF_FORMFILLINFO {
    #[doc = " Version number of the interface."]
    #[doc = " Version 1 contains stable interfaces. Version 2 has additional"]
    #[doc = " experimental interfaces."]
    #[doc = " When PDFium is built without the XFA module, version can be 1 or 2."]
    #[doc = " With version 1, only stable interfaces are called. With version 2,"]
    #[doc = " additional experimental interfaces are also called."]
    #[doc = " When PDFium is built with the XFA module, version must be 2."]
    #[doc = " All the XFA related interfaces are experimental. If PDFium is built with"]
    #[doc = " the XFA module and version 1 then none of the XFA related interfaces"]
    #[doc = " would be called. When PDFium is built with XFA module then the version"]
    #[doc = " must be 2."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Version 1. */"]
    #[doc = " Method: Release"]
    #[doc = "       Give the implementation a chance to release any resources after the"]
    #[doc = "       interface is no longer used."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       No"]
    #[doc = " Comments:"]
    #[doc = "       Called by PDFium during the final cleanup process."]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = " Return Value:"]
    #[doc = "       None"]
    pub Release: ::std::option::Option<unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO)>,
    #[doc = " Method: FFI_Invalidate"]
    #[doc = "       Invalidate the client area within the specified rectangle."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       page        -   Handle to the page. Returned by FPDF_LoadPage()."]
    #[doc = "       left        -   Left position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       top         -   Top position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       right       -   Right position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       bottom      -   Bottom position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       All positions are measured in PDF \"user space\"."]
    #[doc = "       Implementation should call FPDF_RenderPageBitmap() for repainting"]
    #[doc = "       the specified page area."]
    pub FFI_Invalidate: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            left: f64,
            top: f64,
            right: f64,
            bottom: f64,
        ),
    >,
    #[doc = " Method: FFI_OutputSelectedRect"]
    #[doc = "       When the user selects text in form fields with the mouse, this"]
    #[doc = "       callback function will be invoked with the selected areas."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       No"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       page        -   Handle to the page. Returned by FPDF_LoadPage()/"]
    #[doc = "       left        -   Left position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       top         -   Top position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       right       -   Right position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       bottom      -   Bottom position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       This callback function is useful for implementing special text"]
    #[doc = "       selection effects. An implementation should first record the"]
    #[doc = "       returned rectangles, then draw them one by one during the next"]
    #[doc = "       painting period. Lastly, it should remove all the recorded"]
    #[doc = "       rectangles when finished painting."]
    pub FFI_OutputSelectedRect: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            left: f64,
            top: f64,
            right: f64,
            bottom: f64,
        ),
    >,
    #[doc = " Method: FFI_SetCursor"]
    #[doc = "       Set the Cursor shape."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       nCursorType -   Cursor type, see Flags for Cursor type for details."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_SetCursor: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, nCursorType: ::std::os::raw::c_int),
    >,
    #[doc = " Method: FFI_SetTimer"]
    #[doc = "       This method installs a system timer. An interval value is specified,"]
    #[doc = "       and every time that interval elapses, the system must call into the"]
    #[doc = "       callback function with the timer ID as returned by this function."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       uElapse     -   Specifies the time-out value, in milliseconds."]
    #[doc = "       lpTimerFunc -   A pointer to the callback function-TimerCallback."]
    #[doc = " Return value:"]
    #[doc = "       The timer identifier of the new timer if the function is successful."]
    #[doc = "       An application passes this value to the FFI_KillTimer method to kill"]
    #[doc = "       the timer. Nonzero if it is successful; otherwise, it is zero."]
    pub FFI_SetTimer: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            uElapse: ::std::os::raw::c_int,
            lpTimerFunc: TimerCallback,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_KillTimer"]
    #[doc = "       This method uninstalls a system timer, as set by an earlier call to"]
    #[doc = "       FFI_SetTimer."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       nTimerID    -   The timer ID returned by FFI_SetTimer function."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_KillTimer: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, nTimerID: ::std::os::raw::c_int),
    >,
    #[doc = " Method: FFI_GetLocalTime"]
    #[doc = "       This method receives the current local time on the system."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = " Return value:"]
    #[doc = "       The local time. See FPDF_SYSTEMTIME above for details."]
    #[doc = " Note: Unused."]
    pub FFI_GetLocalTime: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO) -> FPDF_SYSTEMTIME,
    >,
    #[doc = " Method: FFI_OnChange"]
    #[doc = "       This method will be invoked to notify the implementation when the"]
    #[doc = "       value of any FormField on the document had been changed."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       no"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_OnChange: ::std::option::Option<unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO)>,
    #[doc = " Method: FFI_GetPage"]
    #[doc = "       This method receives the page handle associated with a specified"]
    #[doc = "       page index."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       document    -   Handle to document. Returned by FPDF_LoadDocument()."]
    #[doc = "       nPageIndex  -   Index number of the page. 0 for the first page."]
    #[doc = " Return value:"]
    #[doc = "       Handle to the page, as previously returned to the implementation by"]
    #[doc = "       FPDF_LoadPage()."]
    #[doc = " Comments:"]
    #[doc = "       The implementation is expected to keep track of the page handles it"]
    #[doc = "       receives from PDFium, and their mappings to page numbers. In some"]
    #[doc = "       cases, the document-level JavaScript action may refer to a page"]
    #[doc = "       which hadn't been loaded yet. To successfully run the Javascript"]
    #[doc = "       action, the implementation needs to load the page."]
    pub FFI_GetPage: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
            nPageIndex: ::std::os::raw::c_int,
        ) -> FPDF_PAGE,
    >,
    #[doc = " Method: FFI_GetCurrentPage"]
    #[doc = "       This method receives the handle to the current page."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       Yes when V8 support is present, otherwise unused."]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       document    -   Handle to document. Returned by FPDF_LoadDocument()."]
    #[doc = " Return value:"]
    #[doc = "       Handle to the page. Returned by FPDF_LoadPage()."]
    #[doc = " Comments:"]
    #[doc = "       PDFium doesn't keep keep track of the \"current page\" (e.g. the one"]
    #[doc = "       that is most visible on screen), so it must ask the embedder for"]
    #[doc = "       this information."]
    pub FFI_GetCurrentPage: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, document: FPDF_DOCUMENT) -> FPDF_PAGE,
    >,
    #[doc = " Method: FFI_GetRotation"]
    #[doc = "       This method receives currently rotation of the page view."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       page        -   Handle to page, as returned by FPDF_LoadPage()."]
    #[doc = " Return value:"]
    #[doc = "       A number to indicate the page rotation in 90 degree increments"]
    #[doc = "       in a clockwise direction:"]
    #[doc = "         0 - 0 degrees"]
    #[doc = "         1 - 90 degrees"]
    #[doc = "         2 - 180 degrees"]
    #[doc = "         3 - 270 degrees"]
    #[doc = " Note: Unused."]
    pub FFI_GetRotation: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_ExecuteNamedAction"]
    #[doc = "       This method will execute a named action."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       namedAction     -   A byte string which indicates the named action,"]
    #[doc = "                           terminated by 0."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       See the named actions description of <<PDF Reference, version 1.7>>"]
    #[doc = "       for more details."]
    pub FFI_ExecuteNamedAction: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, namedAction: FPDF_BYTESTRING),
    >,
    #[doc = " Method: FFI_SetTextFieldFocus"]
    #[doc = "       Called when a text field is getting or losing focus."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       no"]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       value           -   The string value of the form field, in UTF-16LE"]
    #[doc = "                           format."]
    #[doc = "       valueLen        -   The length of the string value. This is the"]
    #[doc = "                           number of characters, not bytes."]
    #[doc = "       is_focus        -   True if the form field is getting focus, false"]
    #[doc = "                           if the form field is losing focus."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       Only supports text fields and combobox fields."]
    pub FFI_SetTextFieldFocus: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            value: FPDF_WIDESTRING,
            valueLen: FPDF_DWORD,
            is_focus: FPDF_BOOL,
        ),
    >,
    #[doc = " Method: FFI_DoURIAction"]
    #[doc = "       Ask the implementation to navigate to a uniform resource identifier."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       No"]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       bsURI           -   A byte string which indicates the uniform"]
    #[doc = "                           resource identifier, terminated by 0."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       If the embedder is version 2 or higher and have implementation for"]
    #[doc = "       FFI_DoURIActionWithKeyboardModifier, then"]
    #[doc = "       FFI_DoURIActionWithKeyboardModifier takes precedence over"]
    #[doc = "       FFI_DoURIAction."]
    #[doc = "       See the URI actions description of <<PDF Reference, version 1.7>>"]
    #[doc = "       for more details."]
    pub FFI_DoURIAction: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, bsURI: FPDF_BYTESTRING),
    >,
    #[doc = " Method: FFI_DoGoToAction"]
    #[doc = "       This action changes the view to a specified destination."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       No"]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       nPageIndex      -   The index of the PDF page."]
    #[doc = "       zoomMode        -   The zoom mode for viewing page. See below."]
    #[doc = "       fPosArray       -   The float array which carries the position info."]
    #[doc = "       sizeofArray     -   The size of float array."]
    #[doc = " PDFZoom values:"]
    #[doc = "         - XYZ = 1"]
    #[doc = "         - FITPAGE = 2"]
    #[doc = "         - FITHORZ = 3"]
    #[doc = "         - FITVERT = 4"]
    #[doc = "         - FITRECT = 5"]
    #[doc = "         - FITBBOX = 6"]
    #[doc = "         - FITBHORZ = 7"]
    #[doc = "         - FITBVERT = 8"]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       See the Destinations description of <<PDF Reference, version 1.7>>"]
    #[doc = "       in 8.2.1 for more details."]
    pub FFI_DoGoToAction: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            nPageIndex: ::std::os::raw::c_int,
            zoomMode: ::std::os::raw::c_int,
            fPosArray: *mut f32,
            sizeofArray: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Pointer to IPDF_JSPLATFORM interface."]
    #[doc = " Unused if PDFium is built without V8 support. Otherwise, if NULL, then"]
    #[doc = " JavaScript will be prevented from executing while rendering the document."]
    pub m_pJsPlatform: *mut IPDF_JSPLATFORM,
    #[doc = " Version 2 - Experimental. */"]
    #[doc = " Whether the XFA module is disabled when built with the XFA module."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    pub xfa_disabled: FPDF_BOOL,
    #[doc = " Method: FFI_DisplayCaret"]
    #[doc = "       This method will show the caret at specified position."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       page            -   Handle to page. Returned by FPDF_LoadPage()."]
    #[doc = "       left            -   Left position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = "       top             -   Top position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = "       right           -   Right position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = "       bottom          -   Bottom position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_DisplayCaret: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            bVisible: FPDF_BOOL,
            left: f64,
            top: f64,
            right: f64,
            bottom: f64,
        ),
    >,
    #[doc = " Method: FFI_GetCurrentPageIndex"]
    #[doc = "       This method will get the current page index."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       document        -   Handle to document from FPDF_LoadDocument()."]
    #[doc = " Return value:"]
    #[doc = "       The index of current page."]
    pub FFI_GetCurrentPageIndex: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_SetCurrentPage"]
    #[doc = "       This method will set the current page."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       document        -   Handle to document from FPDF_LoadDocument()."]
    #[doc = "       iCurPage        -   The index of the PDF page."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_SetCurrentPage: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
            iCurPage: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Method: FFI_GotoURL"]
    #[doc = "       This method will navigate to the specified URL."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis            -   Pointer to the interface structure itself."]
    #[doc = "       document         -   Handle to document from FPDF_LoadDocument()."]
    #[doc = "       wsURL            -   The string value of the URL, in UTF-16LE format."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_GotoURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
            wsURL: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: FFI_GetPageViewRect"]
    #[doc = "       This method will get the current page view rectangle."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       page            -   Handle to page. Returned by FPDF_LoadPage()."]
    #[doc = "       left            -   The pointer to receive left position of the page"]
    #[doc = "                           view area in PDF page coordinates."]
    #[doc = "       top             -   The pointer to receive top position of the page"]
    #[doc = "                           view area in PDF page coordinates."]
    #[doc = "       right           -   The pointer to receive right position of the"]
    #[doc = "                           page view area in PDF page coordinates."]
    #[doc = "       bottom          -   The pointer to receive bottom position of the"]
    #[doc = "                           page view area in PDF page coordinates."]
    #[doc = " Return value:"]
    #[doc = "     None."]
    pub FFI_GetPageViewRect: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            left: *mut f64,
            top: *mut f64,
            right: *mut f64,
            bottom: *mut f64,
        ),
    >,
    #[doc = " Method: FFI_PageEvent"]
    #[doc = "       This method fires when pages have been added to or deleted from"]
    #[doc = "       the XFA document."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       page_count      -   The number of pages to be added or deleted."]
    #[doc = "       event_type      -   See FXFA_PAGEVIEWEVENT_* above."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       The pages to be added or deleted always start from the last page"]
    #[doc = "       of document. This means that if parameter page_count is 2 and"]
    #[doc = "       event type is FXFA_PAGEVIEWEVENT_POSTADDED, 2 new pages have been"]
    #[doc = "       appended to the tail of document; If page_count is 2 and"]
    #[doc = "       event type is FXFA_PAGEVIEWEVENT_POSTREMOVED, the last 2 pages"]
    #[doc = "       have been deleted."]
    pub FFI_PageEvent: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page_count: ::std::os::raw::c_int,
            event_type: FPDF_DWORD,
        ),
    >,
    #[doc = " Method: FFI_PopupMenu"]
    #[doc = "       This method will track the right context menu for XFA fields."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       page            -   Handle to page. Returned by FPDF_LoadPage()."]
    #[doc = "       hWidget         -   Always null, exists for compatibility."]
    #[doc = "       menuFlag        -   The menu flags. Please refer to macro definition"]
    #[doc = "                           of FXFA_MENU_XXX and this can be one or a"]
    #[doc = "                           combination of these macros."]
    #[doc = "       x               -   X position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = "       y               -   Y position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = " Return value:"]
    #[doc = "       TRUE indicates success; otherwise false."]
    pub FFI_PopupMenu: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            hWidget: FPDF_WIDGET,
            menuFlag: ::std::os::raw::c_int,
            x: f32,
            y: f32,
        ) -> FPDF_BOOL,
    >,
    #[doc = " Method: FFI_OpenFile"]
    #[doc = "       This method will open the specified file with the specified mode."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       fileFlag        -   The file flag. Please refer to macro definition"]
    #[doc = "                           of FXFA_SAVEAS_XXX and use one of these macros."]
    #[doc = "       wsURL           -   The string value of the file URL, in UTF-16LE"]
    #[doc = "                           format."]
    #[doc = "       mode            -   The mode for open file, e.g. \"rb\" or \"wb\"."]
    #[doc = " Return value:"]
    #[doc = "       The handle to FPDF_FILEHANDLER."]
    pub FFI_OpenFile: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            fileFlag: ::std::os::raw::c_int,
            wsURL: FPDF_WIDESTRING,
            mode: *const ::std::os::raw::c_char,
        ) -> *mut FPDF_FILEHANDLER,
    >,
    #[doc = " Method: FFI_EmailTo"]
    #[doc = "       This method will email the specified file stream to the specified"]
    #[doc = "       contact."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       pFileHandler    -   Handle to the FPDF_FILEHANDLER."]
    #[doc = "       pTo             -   A semicolon-delimited list of recipients for the"]
    #[doc = "                           message,in UTF-16LE format."]
    #[doc = "       pSubject        -   The subject of the message,in UTF-16LE format."]
    #[doc = "       pCC             -   A semicolon-delimited list of CC recipients for"]
    #[doc = "                           the message,in UTF-16LE format."]
    #[doc = "       pBcc            -   A semicolon-delimited list of BCC recipients for"]
    #[doc = "                           the message,in UTF-16LE format."]
    #[doc = "       pMsg            -   Pointer to the data buffer to be sent.Can be"]
    #[doc = "                           NULL,in UTF-16LE format."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_EmailTo: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            fileHandler: *mut FPDF_FILEHANDLER,
            pTo: FPDF_WIDESTRING,
            pSubject: FPDF_WIDESTRING,
            pCC: FPDF_WIDESTRING,
            pBcc: FPDF_WIDESTRING,
            pMsg: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: FFI_UploadTo"]
    #[doc = "       This method will upload the specified file stream to the"]
    #[doc = "       specified URL."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       pFileHandler    -   Handle to the FPDF_FILEHANDLER."]
    #[doc = "       fileFlag        -   The file flag. Please refer to macro definition"]
    #[doc = "                           of FXFA_SAVEAS_XXX and use one of these macros."]
    #[doc = "       uploadTo        -   Pointer to the URL path, in UTF-16LE format."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_UploadTo: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            fileHandler: *mut FPDF_FILEHANDLER,
            fileFlag: ::std::os::raw::c_int,
            uploadTo: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: FFI_GetPlatform"]
    #[doc = "       This method will get the current platform."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       platform        -   Pointer to the data buffer to receive the"]
    #[doc = "                           platform,in UTF-16LE format. Can be NULL."]
    #[doc = "       length          -   The length of the buffer in bytes. Can be"]
    #[doc = "                           0 to query the required size."]
    #[doc = " Return value:"]
    #[doc = "       The length of the buffer, number of bytes."]
    pub FFI_GetPlatform: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            platform: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_GetLanguage"]
    #[doc = "       This method will get the current language."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       language        -   Pointer to the data buffer to receive the"]
    #[doc = "                           current language. Can be NULL."]
    #[doc = "       length          -   The length of the buffer in bytes. Can be"]
    #[doc = "                           0 to query the required size."]
    #[doc = " Return value:"]
    #[doc = "       The length of the buffer, number of bytes."]
    pub FFI_GetLanguage: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            language: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_DownloadFromURL"]
    #[doc = "       This method will download the specified file from the URL."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       URL             -   The string value of the file URL, in UTF-16LE"]
    #[doc = "                           format."]
    #[doc = " Return value:"]
    #[doc = "       The handle to FPDF_FILEHANDLER."]
    pub FFI_DownloadFromURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            URL: FPDF_WIDESTRING,
        ) -> *mut FPDF_FILEHANDLER,
    >,
    #[doc = " Method: FFI_PostRequestURL"]
    #[doc = "       This method will post the request to the server URL."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       wsURL           -   The string value of the server URL, in UTF-16LE"]
    #[doc = "                           format."]
    #[doc = "       wsData          -   The post data,in UTF-16LE format."]
    #[doc = "       wsContentType   -   The content type of the request data, in"]
    #[doc = "                           UTF-16LE format."]
    #[doc = "       wsEncode        -   The encode type, in UTF-16LE format."]
    #[doc = "       wsHeader        -   The request header,in UTF-16LE format."]
    #[doc = "       response        -   Pointer to the FPDF_BSTR to receive the response"]
    #[doc = "                           data from the server, in UTF-16LE format."]
    #[doc = " Return value:"]
    #[doc = "       TRUE indicates success, otherwise FALSE."]
    pub FFI_PostRequestURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            wsURL: FPDF_WIDESTRING,
            wsData: FPDF_WIDESTRING,
            wsContentType: FPDF_WIDESTRING,
            wsEncode: FPDF_WIDESTRING,
            wsHeader: FPDF_WIDESTRING,
            response: *mut FPDF_BSTR,
        ) -> FPDF_BOOL,
    >,
    #[doc = " Method: FFI_PutRequestURL"]
    #[doc = "       This method will put the request to the server URL."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       wsURL           -   The string value of the server URL, in UTF-16LE"]
    #[doc = "                           format."]
    #[doc = "       wsData          -   The put data, in UTF-16LE format."]
    #[doc = "       wsEncode        -   The encode type, in UTR-16LE format."]
    #[doc = " Return value:"]
    #[doc = "       TRUE indicates success, otherwise FALSE."]
    pub FFI_PutRequestURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            wsURL: FPDF_WIDESTRING,
            wsData: FPDF_WIDESTRING,
            wsEncode: FPDF_WIDESTRING,
        ) -> FPDF_BOOL,
    >,
    #[doc = " Method: FFI_OnFocusChange"]
    #[doc = "     Called when the focused annotation is updated."]
    #[doc = " Interface Version:"]
    #[doc = "     Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "     No"]
    #[doc = " Parameters:"]
    #[doc = "     param           -   Pointer to the interface structure itself."]
    #[doc = "     annot           -   The focused annotation."]
    #[doc = "     page_index      -   Index number of the page which contains the"]
    #[doc = "                         focused annotation. 0 for the first page."]
    #[doc = " Return value:"]
    #[doc = "     None."]
    #[doc = " Comments:"]
    #[doc = "     This callback function is useful for implementing any view based"]
    #[doc = "     action such as scrolling the annotation rect into view. The"]
    #[doc = "     embedder should not copy and store the annot as its scope is"]
    #[doc = "     limited to this call only."]
    pub FFI_OnFocusChange: ::std::option::Option<
        unsafe extern "C" fn(
            param: *mut _FPDF_FORMFILLINFO,
            annot: FPDF_ANNOTATION,
            page_index: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Method: FFI_DoURIActionWithKeyboardModifier"]
    #[doc = "       Ask the implementation to navigate to a uniform resource identifier"]
    #[doc = "       with the specified modifiers."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       No"]
    #[doc = " Parameters:"]
    #[doc = "       param           -   Pointer to the interface structure itself."]
    #[doc = "       uri             -   A byte string which indicates the uniform"]
    #[doc = "                           resource identifier, terminated by 0."]
    #[doc = "       modifiers       -   Keyboard modifier that indicates which of"]
    #[doc = "                           the virtual keys are down, if any."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       If the embedder who is version 2 and does not implement this API,"]
    #[doc = "       then a call will be redirected to FFI_DoURIAction."]
    #[doc = "       See the URI actions description of <<PDF Reference, version 1.7>>"]
    #[doc = "       for more details."]
    pub FFI_DoURIActionWithKeyboardModifier: ::std::option::Option<
        unsafe extern "C" fn(
            param: *mut _FPDF_FORMFILLINFO,
            uri: FPDF_BYTESTRING,
            modifiers: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__FPDF_FORMFILLINFO() {
    assert_eq!(
        ::std::mem::size_of::<_FPDF_FORMFILLINFO>(),
        280usize,
        concat!("Size of: ", stringify!(_FPDF_FORMFILLINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_FPDF_FORMFILLINFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_FPDF_FORMFILLINFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).Release as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(Release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_Invalidate as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_Invalidate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_OutputSelectedRect as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OutputSelectedRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_SetCursor as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetCursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_SetTimer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetTimer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_KillTimer as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_KillTimer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetLocalTime as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetLocalTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_OnChange as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OnChange)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetPage as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetPage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetCurrentPage as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetCurrentPage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetRotation as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetRotation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_ExecuteNamedAction as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_ExecuteNamedAction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_SetTextFieldFocus as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetTextFieldFocus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_DoURIAction as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DoURIAction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_DoGoToAction as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DoGoToAction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).m_pJsPlatform as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(m_pJsPlatform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).xfa_disabled as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(xfa_disabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_DisplayCaret as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DisplayCaret)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetCurrentPageIndex as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetCurrentPageIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_SetCurrentPage as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetCurrentPage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GotoURL as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GotoURL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetPageViewRect as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetPageViewRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_PageEvent as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PageEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_PopupMenu as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PopupMenu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_OpenFile as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OpenFile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_EmailTo as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_EmailTo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_UploadTo as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_UploadTo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetPlatform as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetPlatform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetLanguage as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetLanguage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_DownloadFromURL as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DownloadFromURL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_PostRequestURL as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PostRequestURL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_PutRequestURL as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PutRequestURL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_OnFocusChange as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OnFocusChange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_DoURIActionWithKeyboardModifier
                as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DoURIActionWithKeyboardModifier)
        )
    );
}
pub type FPDF_FORMFILLINFO = _FPDF_FORMFILLINFO;
extern "C" {
    #[doc = " Function: FPDFDOC_InitFormFillEnvironment"]
    #[doc = "       Initialize form fill environment."]
    #[doc = " Parameters:"]
    #[doc = "       document        -   Handle to document from FPDF_LoadDocument()."]
    #[doc = "       pFormFillInfo   -   Pointer to a FPDF_FORMFILLINFO structure."]
    #[doc = " Return Value:"]
    #[doc = "       Handle to the form fill module, or NULL on failure."]
    #[doc = " Comments:"]
    #[doc = "       This function should be called before any form fill operation."]
    pub fn FPDFDOC_InitFormFillEnvironment(
        document: FPDF_DOCUMENT,
        formInfo: *mut FPDF_FORMFILLINFO,
    ) -> FPDF_FORMHANDLE;
}
extern "C" {
    #[doc = " Function: FPDFDOC_ExitFormFillEnvironment"]
    #[doc = "       Take ownership of |hHandle| and exit form fill environment."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       This function is a no-op when |hHandle| is null."]
    pub fn FPDFDOC_ExitFormFillEnvironment(hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FORM_OnAfterLoadPage"]
    #[doc = "       This method is required for implementing all the form related"]
    #[doc = "       functions. Should be invoked after user successfully loaded a"]
    #[doc = "       PDF page, and FPDFDOC_InitFormFillEnvironment() has been invoked."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    pub fn FORM_OnAfterLoadPage(page: FPDF_PAGE, hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FORM_OnBeforeClosePage"]
    #[doc = "       This method is required for implementing all the form related"]
    #[doc = "       functions. Should be invoked before user closes the PDF page."]
    #[doc = " Parameters:"]
    #[doc = "        page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "        hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                        FPDFDOC_InitFormFillEnvironment()."]
    #[doc = " Return Value:"]
    #[doc = "        None."]
    pub fn FORM_OnBeforeClosePage(page: FPDF_PAGE, hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FORM_DoDocumentJSAction"]
    #[doc = "       This method is required for performing document-level JavaScript"]
    #[doc = "       actions. It should be invoked after the PDF document has been loaded."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       If there is document-level JavaScript action embedded in the"]
    #[doc = "       document, this method will execute the JavaScript action. Otherwise,"]
    #[doc = "       the method will do nothing."]
    pub fn FORM_DoDocumentJSAction(hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FORM_DoDocumentOpenAction"]
    #[doc = "       This method is required for performing open-action when the document"]
    #[doc = "       is opened."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       This method will do nothing if there are no open-actions embedded"]
    #[doc = "       in the document."]
    pub fn FORM_DoDocumentOpenAction(hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FORM_DoDocumentAAction"]
    #[doc = "       This method is required for performing the document's"]
    #[doc = "       additional-action."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module. Returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment."]
    #[doc = "       aaType      -   The type of the additional-actions which defined"]
    #[doc = "                       above."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       This method will do nothing if there is no document"]
    #[doc = "       additional-action corresponding to the specified |aaType|."]
    pub fn FORM_DoDocumentAAction(hHandle: FPDF_FORMHANDLE, aaType: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Function: FORM_DoPageAAction"]
    #[doc = "       This method is required for performing the page object's"]
    #[doc = "       additional-action when opened or closed."]
    #[doc = " Parameters:"]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       aaType      -   The type of the page object's additional-actions"]
    #[doc = "                       which defined above."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       This method will do nothing if no additional-action corresponding"]
    #[doc = "       to the specified |aaType| exists."]
    pub fn FORM_DoPageAAction(
        page: FPDF_PAGE,
        hHandle: FPDF_FORMHANDLE,
        aaType: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Function: FORM_OnMouseMove"]
    #[doc = "       Call this member function when the mouse cursor moves."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       modifier    -   Indicates whether various virtual keys are down."]
    #[doc = "       page_x      -   Specifies the x-coordinate of the cursor in PDF user"]
    #[doc = "                       space."]
    #[doc = "       page_y      -   Specifies the y-coordinate of the cursor in PDF user"]
    #[doc = "                       space."]
    #[doc = " Return Value:"]
    #[doc = "       True indicates success; otherwise false."]
    pub fn FORM_OnMouseMove(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API"]
    #[doc = " Function: FORM_OnMouseWheel"]
    #[doc = "       Call this member function when the user scrolls the mouse wheel."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       modifier    -   Indicates whether various virtual keys are down."]
    #[doc = "       page_coord  -   Specifies the coordinates of the cursor in PDF user"]
    #[doc = "                       space."]
    #[doc = "       delta_x     -   Specifies the amount of wheel movement on the x-axis,"]
    #[doc = "                       in units of platform-agnostic wheel deltas. Negative"]
    #[doc = "                       values mean left."]
    #[doc = "       delta_y     -   Specifies the amount of wheel movement on the y-axis,"]
    #[doc = "                       in units of platform-agnostic wheel deltas. Negative"]
    #[doc = "                       values mean down."]
    #[doc = " Return Value:"]
    #[doc = "       True indicates success; otherwise false."]
    #[doc = " Comments:"]
    #[doc = "       For |delta_x| and |delta_y|, the caller must normalize"]
    #[doc = "       platform-specific wheel deltas. e.g. On Windows, a delta value of 240"]
    #[doc = "       for a WM_MOUSEWHEEL event normalizes to 2, since Windows defines"]
    #[doc = "       WHEEL_DELTA as 120."]
    pub fn FORM_OnMouseWheel(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_coord: *const FS_POINTF,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnFocus"]
    #[doc = "       This function focuses the form annotation at a given point. If the"]
    #[doc = "       annotation at the point already has focus, nothing happens. If there"]
    #[doc = "       is no annotation at the point, removes form focus."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       modifier    -   Indicates whether various virtual keys are down."]
    #[doc = "       page_x      -   Specifies the x-coordinate of the cursor in PDF user"]
    #[doc = "                       space."]
    #[doc = "       page_y      -   Specifies the y-coordinate of the cursor in PDF user"]
    #[doc = "                       space."]
    #[doc = " Return Value:"]
    #[doc = "       True if there is an annotation at the given point and it has focus."]
    pub fn FORM_OnFocus(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnLButtonDown"]
    #[doc = "       Call this member function when the user presses the left"]
    #[doc = "       mouse button."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       modifier    -   Indicates whether various virtual keys are down."]
    #[doc = "       page_x      -   Specifies the x-coordinate of the cursor in PDF user"]
    #[doc = "                       space."]
    #[doc = "       page_y      -   Specifies the y-coordinate of the cursor in PDF user"]
    #[doc = "                       space."]
    #[doc = " Return Value:"]
    #[doc = "       True indicates success; otherwise false."]
    pub fn FORM_OnLButtonDown(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnRButtonDown"]
    #[doc = "       Same as above, execpt for the right mouse button."]
    #[doc = " Comments:"]
    #[doc = "       At the present time, has no effect except in XFA builds, but is"]
    #[doc = "       included for the sake of symmetry."]
    pub fn FORM_OnRButtonDown(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnLButtonUp"]
    #[doc = "       Call this member function when the user releases the left"]
    #[doc = "       mouse button."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       modifier    -   Indicates whether various virtual keys are down."]
    #[doc = "       page_x      -   Specifies the x-coordinate of the cursor in device."]
    #[doc = "       page_y      -   Specifies the y-coordinate of the cursor in device."]
    #[doc = " Return Value:"]
    #[doc = "       True indicates success; otherwise false."]
    pub fn FORM_OnLButtonUp(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnRButtonUp"]
    #[doc = "       Same as above, execpt for the right mouse button."]
    #[doc = " Comments:"]
    #[doc = "       At the present time, has no effect except in XFA builds, but is"]
    #[doc = "       included for the sake of symmetry."]
    pub fn FORM_OnRButtonUp(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnLButtonDoubleClick"]
    #[doc = "       Call this member function when the user double clicks the"]
    #[doc = "       left mouse button."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       modifier    -   Indicates whether various virtual keys are down."]
    #[doc = "       page_x      -   Specifies the x-coordinate of the cursor in PDF user"]
    #[doc = "                       space."]
    #[doc = "       page_y      -   Specifies the y-coordinate of the cursor in PDF user"]
    #[doc = "                       space."]
    #[doc = " Return Value:"]
    #[doc = "       True indicates success; otherwise false."]
    pub fn FORM_OnLButtonDoubleClick(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        modifier: ::std::os::raw::c_int,
        page_x: f64,
        page_y: f64,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnKeyDown"]
    #[doc = "       Call this member function when a nonsystem key is pressed."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, aseturned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       nKeyCode    -   Indicates whether various virtual keys are down."]
    #[doc = "       modifier    -   Contains the scan code, key-transition code,"]
    #[doc = "                       previous key state, and context code."]
    #[doc = " Return Value:"]
    #[doc = "       True indicates success; otherwise false."]
    pub fn FORM_OnKeyDown(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        nKeyCode: ::std::os::raw::c_int,
        modifier: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnKeyUp"]
    #[doc = "       Call this member function when a nonsystem key is released."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       nKeyCode    -   The virtual-key code of the given key."]
    #[doc = "       modifier    -   Contains the scan code, key-transition code,"]
    #[doc = "                       previous key state, and context code."]
    #[doc = " Return Value:"]
    #[doc = "       True indicates success; otherwise false."]
    pub fn FORM_OnKeyUp(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        nKeyCode: ::std::os::raw::c_int,
        modifier: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_OnChar"]
    #[doc = "       Call this member function when a keystroke translates to a"]
    #[doc = "       nonsystem character."]
    #[doc = " Parameters:"]
    #[doc = "        hHandle    -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "        page       -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "        nChar      -   The character code value of the key."]
    #[doc = "        modifier   -   Contains the scan code, key-transition code,"]
    #[doc = "                       previous key state, and context code."]
    #[doc = " Return Value:"]
    #[doc = "       True indicates success; otherwise false."]
    pub fn FORM_OnChar(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        nChar: ::std::os::raw::c_int,
        modifier: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API"]
    #[doc = " Function: FORM_GetFocusedText"]
    #[doc = "       Call this function to obtain the text within the current focused"]
    #[doc = "       field, if any."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       buffer      -   Buffer for holding the form text, encoded in"]
    #[doc = "                       UTF-16LE. If NULL, |buffer| is not modified."]
    #[doc = "       buflen      -   Length of |buffer| in bytes. If |buflen| is less"]
    #[doc = "                       than the length of the form text string, |buffer| is"]
    #[doc = "                       not modified."]
    #[doc = " Return Value:"]
    #[doc = "       Length in bytes for the text in the focused field."]
    pub fn FORM_GetFocusedText(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FORM_GetSelectedText"]
    #[doc = "       Call this function to obtain selected text within a form text"]
    #[doc = "       field or form combobox text field."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       buffer      -   Buffer for holding the selected text, encoded in"]
    #[doc = "                       UTF-16LE. If NULL, |buffer| is not modified."]
    #[doc = "       buflen      -   Length of |buffer| in bytes. If |buflen| is less"]
    #[doc = "                       than the length of the selected text string,"]
    #[doc = "                       |buffer| is not modified."]
    #[doc = " Return Value:"]
    #[doc = "       Length in bytes of selected text in form text field or form combobox"]
    #[doc = "       text field."]
    pub fn FORM_GetSelectedText(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        buffer: *mut ::std::os::raw::c_void,
        buflen: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Function: FORM_ReplaceSelection"]
    #[doc = "       Call this function to replace the selected text in a form"]
    #[doc = "       text field or user-editable form combobox text field with another"]
    #[doc = "       text string (which can be empty or non-empty). If there is no"]
    #[doc = "       selected text, this function will append the replacement text after"]
    #[doc = "       the current caret position."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as Returned by FPDF_LoadPage()."]
    #[doc = "       wsText      -   The text to be inserted, in UTF-16LE format."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    pub fn FORM_ReplaceSelection(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        wsText: FPDF_WIDESTRING,
    );
}
extern "C" {
    #[doc = " Experimental API"]
    #[doc = " Function: FORM_SelectAllText"]
    #[doc = "       Call this function to select all the text within the currently focused"]
    #[doc = "       form text field or form combobox text field."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = " Return Value:"]
    #[doc = "       Whether the operation succeeded or not."]
    pub fn FORM_SelectAllText(hHandle: FPDF_FORMHANDLE, page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_CanUndo"]
    #[doc = "       Find out if it is possible for the current focused widget in a given"]
    #[doc = "       form to perform an undo operation."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = " Return Value:"]
    #[doc = "       True if it is possible to undo."]
    pub fn FORM_CanUndo(hHandle: FPDF_FORMHANDLE, page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_CanRedo"]
    #[doc = "       Find out if it is possible for the current focused widget in a given"]
    #[doc = "       form to perform a redo operation."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = " Return Value:"]
    #[doc = "       True if it is possible to redo."]
    pub fn FORM_CanRedo(hHandle: FPDF_FORMHANDLE, page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_Undo"]
    #[doc = "       Make the current focussed widget perform an undo operation."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = " Return Value:"]
    #[doc = "       True if the undo operation succeeded."]
    pub fn FORM_Undo(hHandle: FPDF_FORMHANDLE, page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_Redo"]
    #[doc = "       Make the current focussed widget perform a redo operation."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page        -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = " Return Value:"]
    #[doc = "       True if the redo operation succeeded."]
    pub fn FORM_Redo(hHandle: FPDF_FORMHANDLE, page: FPDF_PAGE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FORM_ForceToKillFocus."]
    #[doc = "       Call this member function to force to kill the focus of the form"]
    #[doc = "       field which has focus. If it would kill the focus of a form field,"]
    #[doc = "       save the value of form field if was changed by theuser."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = " Return Value:"]
    #[doc = "       True indicates success; otherwise false."]
    pub fn FORM_ForceToKillFocus(hHandle: FPDF_FORMHANDLE) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FORM_GetFocusedAnnot."]
    #[doc = "       Call this member function to get the currently focused annotation."]
    #[doc = " Parameters:"]
    #[doc = "       handle      -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       page_index  -   Buffer to hold the index number of the page which"]
    #[doc = "                       contains the focused annotation. 0 for the first page."]
    #[doc = "                       Can't be NULL."]
    #[doc = "       annot       -   Buffer to hold the focused annotation. Can't be NULL."]
    #[doc = " Return Value:"]
    #[doc = "       On success, return true and write to the out parameters. Otherwise return"]
    #[doc = "       false and leave the out parameters unmodified."]
    #[doc = " Comments:"]
    #[doc = "       Not currently supported for XFA forms - will report no focused"]
    #[doc = "       annotation."]
    #[doc = "       Must call FPDFPage_CloseAnnot() when the annotation returned in |annot|"]
    #[doc = "       by this function is no longer needed."]
    #[doc = "       This will return true and set |page_index| to -1 and |annot| to NULL, if"]
    #[doc = "       there is no focused annotation."]
    pub fn FORM_GetFocusedAnnot(
        handle: FPDF_FORMHANDLE,
        page_index: *mut ::std::os::raw::c_int,
        annot: *mut FPDF_ANNOTATION,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API."]
    #[doc = " Function: FORM_SetFocusedAnnot."]
    #[doc = "       Call this member function to set the currently focused annotation."]
    #[doc = " Parameters:"]
    #[doc = "       handle      -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       annot       -   Handle to an annotation."]
    #[doc = " Return Value:"]
    #[doc = "       True indicates success; otherwise false."]
    #[doc = " Comments:"]
    #[doc = "       |annot| can't be NULL. To kill focus, use FORM_ForceToKillFocus()"]
    #[doc = "       instead."]
    pub fn FORM_SetFocusedAnnot(handle: FPDF_FORMHANDLE, annot: FPDF_ANNOTATION) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDFPage_HasFormFieldAtPoint"]
    #[doc = "     Get the form field type by point."]
    #[doc = " Parameters:"]
    #[doc = "     hHandle     -   Handle to the form fill module. Returned by"]
    #[doc = "                     FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "     page        -   Handle to the page. Returned by FPDF_LoadPage()."]
    #[doc = "     page_x      -   X position in PDF \"user space\"."]
    #[doc = "     page_y      -   Y position in PDF \"user space\"."]
    #[doc = " Return Value:"]
    #[doc = "     Return the type of the form field; -1 indicates no field."]
    #[doc = "     See field types above."]
    pub fn FPDFPage_HasFormFieldAtPoint(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        page_x: f64,
        page_y: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDFPage_FormFieldZOrderAtPoint"]
    #[doc = "     Get the form field z-order by point."]
    #[doc = " Parameters:"]
    #[doc = "     hHandle     -   Handle to the form fill module. Returned by"]
    #[doc = "                     FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "     page        -   Handle to the page. Returned by FPDF_LoadPage()."]
    #[doc = "     page_x      -   X position in PDF \"user space\"."]
    #[doc = "     page_y      -   Y position in PDF \"user space\"."]
    #[doc = " Return Value:"]
    #[doc = "     Return the z-order of the form field; -1 indicates no field."]
    #[doc = "     Higher numbers are closer to the front."]
    pub fn FPDFPage_FormFieldZOrderAtPoint(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        page_x: f64,
        page_y: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Function: FPDF_SetFormFieldHighlightColor"]
    #[doc = "       Set the highlight color of the specified (or all) form fields"]
    #[doc = "       in the document."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       doc         -   Handle to the document, as returned by"]
    #[doc = "                       FPDF_LoadDocument()."]
    #[doc = "       fieldType   -   A 32-bit integer indicating the type of a form"]
    #[doc = "                       field (defined above)."]
    #[doc = "       color       -   The highlight color of the form field. Constructed by"]
    #[doc = "                       0xxxrrggbb."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       When the parameter fieldType is set to FPDF_FORMFIELD_UNKNOWN, the"]
    #[doc = "       highlight color will be applied to all the form fields in the"]
    #[doc = "       document."]
    #[doc = "       Please refresh the client window to show the highlight immediately"]
    #[doc = "       if necessary."]
    pub fn FPDF_SetFormFieldHighlightColor(
        hHandle: FPDF_FORMHANDLE,
        fieldType: ::std::os::raw::c_int,
        color: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    #[doc = " Function: FPDF_SetFormFieldHighlightAlpha"]
    #[doc = "       Set the transparency of the form field highlight color in the"]
    #[doc = "       document."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       doc         -   Handle to the document, as returaned by"]
    #[doc = "                       FPDF_LoadDocument()."]
    #[doc = "       alpha       -   The transparency of the form field highlight color,"]
    #[doc = "                       between 0-255."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    pub fn FPDF_SetFormFieldHighlightAlpha(
        hHandle: FPDF_FORMHANDLE,
        alpha: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    #[doc = " Function: FPDF_RemoveFormFieldHighlight"]
    #[doc = "       Remove the form field highlight color in the document."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle     -   Handle to the form fill module, as returned by"]
    #[doc = "                       FPDFDOC_InitFormFillEnvironment()."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       Please refresh the client window to remove the highlight immediately"]
    #[doc = "       if necessary."]
    pub fn FPDF_RemoveFormFieldHighlight(hHandle: FPDF_FORMHANDLE);
}
extern "C" {
    #[doc = " Function: FPDF_FFLDraw"]
    #[doc = "       Render FormFields and popup window on a page to a device independent"]
    #[doc = "       bitmap."]
    #[doc = " Parameters:"]
    #[doc = "       hHandle      -   Handle to the form fill module, as returned by"]
    #[doc = "                        FPDFDOC_InitFormFillEnvironment()."]
    #[doc = "       bitmap       -   Handle to the device independent bitmap (as the"]
    #[doc = "                        output buffer). Bitmap handles can be created by"]
    #[doc = "                        FPDFBitmap_Create()."]
    #[doc = "       page         -   Handle to the page, as returned by FPDF_LoadPage()."]
    #[doc = "       start_x      -   Left pixel position of the display area in the"]
    #[doc = "                        device coordinates."]
    #[doc = "       start_y      -   Top pixel position of the display area in the device"]
    #[doc = "                        coordinates."]
    #[doc = "       size_x       -   Horizontal size (in pixels) for displaying the page."]
    #[doc = "       size_y       -   Vertical size (in pixels) for displaying the page."]
    #[doc = "       rotate       -   Page orientation: 0 (normal), 1 (rotated 90 degrees"]
    #[doc = "                        clockwise), 2 (rotated 180 degrees), 3 (rotated 90"]
    #[doc = "                        degrees counter-clockwise)."]
    #[doc = "       flags        -   0 for normal display, or combination of flags"]
    #[doc = "                        defined above."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       This function is designed to render annotations that are"]
    #[doc = "       user-interactive, which are widget annotations (for FormFields) and"]
    #[doc = "       popup annotations."]
    #[doc = "       With the FPDF_ANNOT flag, this function will render a popup annotation"]
    #[doc = "       when users mouse-hover on a non-widget annotation. Regardless of"]
    #[doc = "       FPDF_ANNOT flag, this function will always render widget annotations"]
    #[doc = "       for FormFields."]
    #[doc = "       In order to implement the FormFill functions, implementation should"]
    #[doc = "       call this function after rendering functions, such as"]
    #[doc = "       FPDF_RenderPageBitmap() or FPDF_RenderPageBitmap_Start(), have"]
    #[doc = "       finished rendering the page contents."]
    pub fn FPDF_FFLDraw(
        hHandle: FPDF_FORMHANDLE,
        bitmap: FPDF_BITMAP,
        page: FPDF_PAGE,
        start_x: ::std::os::raw::c_int,
        start_y: ::std::os::raw::c_int,
        size_x: ::std::os::raw::c_int,
        size_y: ::std::os::raw::c_int,
        rotate: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Experimental API"]
    #[doc = " Function: FPDF_GetFormType"]
    #[doc = "           Returns the type of form contained in the PDF document."]
    #[doc = " Parameters:"]
    #[doc = "           document - Handle to document."]
    #[doc = " Return Value:"]
    #[doc = "           Integer value representing one of the FORMTYPE_ values."]
    #[doc = " Comments:"]
    #[doc = "           If |document| is NULL, then the return value is FORMTYPE_NONE."]
    pub fn FPDF_GetFormType(document: FPDF_DOCUMENT) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Experimental API"]
    #[doc = " Function: FORM_SetIndexSelected"]
    #[doc = "           Selects/deselects the value at the given |index| of the focused"]
    #[doc = "           annotation."]
    #[doc = " Parameters:"]
    #[doc = "           hHandle     -   Handle to the form fill module. Returned by"]
    #[doc = "                           FPDFDOC_InitFormFillEnvironment."]
    #[doc = "           page        -   Handle to the page. Returned by FPDF_LoadPage"]
    #[doc = "           index       -   0-based index of value to be set as"]
    #[doc = "                           selected/unselected"]
    #[doc = "           selected    -   true to select, false to deselect"]
    #[doc = " Return Value:"]
    #[doc = "           TRUE if the operation succeeded."]
    #[doc = "           FALSE if the operation failed or widget is not a supported type."]
    #[doc = " Comments:"]
    #[doc = "           Intended for use with listbox/combobox widget types. Comboboxes"]
    #[doc = "           have at most a single value selected at a time which cannot be"]
    #[doc = "           deselected. Deselect on a combobox is a no-op that returns false."]
    #[doc = "           Default implementation is a no-op that will return false for"]
    #[doc = "           other types."]
    #[doc = "           Not currently supported for XFA forms - will return false."]
    pub fn FORM_SetIndexSelected(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        index: ::std::os::raw::c_int,
        selected: FPDF_BOOL,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Experimental API"]
    #[doc = " Function: FORM_IsIndexSelected"]
    #[doc = "           Returns whether or not the value at |index| of the focused"]
    #[doc = "           annotation is currently selected."]
    #[doc = " Parameters:"]
    #[doc = "           hHandle     -   Handle to the form fill module. Returned by"]
    #[doc = "                           FPDFDOC_InitFormFillEnvironment."]
    #[doc = "           page        -   Handle to the page. Returned by FPDF_LoadPage"]
    #[doc = "           index       -   0-based Index of value to check"]
    #[doc = " Return Value:"]
    #[doc = "           TRUE if value at |index| is currently selected."]
    #[doc = "           FALSE if value at |index| is not selected or widget is not a"]
    #[doc = "           supported type."]
    #[doc = " Comments:"]
    #[doc = "           Intended for use with listbox/combobox widget types. Default"]
    #[doc = "           implementation is a no-op that will return false for other types."]
    #[doc = "           Not currently supported for XFA forms - will return false."]
    pub fn FORM_IsIndexSelected(
        hHandle: FPDF_FORMHANDLE,
        page: FPDF_PAGE,
        index: ::std::os::raw::c_int,
    ) -> FPDF_BOOL;
}
extern "C" {
    #[doc = " Function: FPDF_LoadXFA"]
    #[doc = "          If the document consists of XFA fields, call this method to"]
    #[doc = "          attempt to load XFA fields."]
    #[doc = " Parameters:"]
    #[doc = "          document     -   Handle to document from FPDF_LoadDocument()."]
    #[doc = " Return Value:"]
    #[doc = "          TRUE upon success, otherwise FALSE. If XFA support is not built"]
    #[doc = "          into PDFium, performs no action and always returns FALSE."]
    pub fn FPDF_LoadXFA(document: FPDF_DOCUMENT) -> FPDF_BOOL;
}
