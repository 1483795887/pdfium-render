/* automatically generated by rust-bindgen 0.59.2 */

pub const FPDF_OBJECT_UNKNOWN: u32 = 0;
pub const FPDF_OBJECT_BOOLEAN: u32 = 1;
pub const FPDF_OBJECT_NUMBER: u32 = 2;
pub const FPDF_OBJECT_STRING: u32 = 3;
pub const FPDF_OBJECT_NAME: u32 = 4;
pub const FPDF_OBJECT_ARRAY: u32 = 5;
pub const FPDF_OBJECT_DICTIONARY: u32 = 6;
pub const FPDF_OBJECT_STREAM: u32 = 7;
pub const FPDF_OBJECT_NULLOBJ: u32 = 8;
pub const FPDF_OBJECT_REFERENCE: u32 = 9;
pub const FPDF_POLICY_MACHINETIME_ACCESS: u32 = 0;
pub const FPDF_ERR_SUCCESS: u32 = 0;
pub const FPDF_ERR_UNKNOWN: u32 = 1;
pub const FPDF_ERR_FILE: u32 = 2;
pub const FPDF_ERR_FORMAT: u32 = 3;
pub const FPDF_ERR_PASSWORD: u32 = 4;
pub const FPDF_ERR_SECURITY: u32 = 5;
pub const FPDF_ERR_PAGE: u32 = 6;
pub const FPDF_ANNOT: u32 = 1;
pub const FPDF_LCD_TEXT: u32 = 2;
pub const FPDF_NO_NATIVETEXT: u32 = 4;
pub const FPDF_GRAYSCALE: u32 = 8;
pub const FPDF_DEBUG_INFO: u32 = 128;
pub const FPDF_NO_CATCH: u32 = 256;
pub const FPDF_RENDER_LIMITEDIMAGECACHE: u32 = 512;
pub const FPDF_RENDER_FORCEHALFTONE: u32 = 1024;
pub const FPDF_PRINTING: u32 = 2048;
pub const FPDF_RENDER_NO_SMOOTHTEXT: u32 = 4096;
pub const FPDF_RENDER_NO_SMOOTHIMAGE: u32 = 8192;
pub const FPDF_RENDER_NO_SMOOTHPATH: u32 = 16384;
pub const FPDF_REVERSE_BYTE_ORDER: u32 = 16;
pub const FPDF_CONVERT_FILL_TO_STROKE: u32 = 32;
pub const FPDFBitmap_Unknown: u32 = 0;
pub const FPDFBitmap_Gray: u32 = 1;
pub const FPDFBitmap_BGR: u32 = 2;
pub const FPDFBitmap_BGRx: u32 = 3;
pub const FPDFBitmap_BGRA: u32 = 4;
pub const PDFACTION_UNSUPPORTED: u32 = 0;
pub const PDFACTION_GOTO: u32 = 1;
pub const PDFACTION_REMOTEGOTO: u32 = 2;
pub const PDFACTION_URI: u32 = 3;
pub const PDFACTION_LAUNCH: u32 = 4;
pub const PDFACTION_EMBEDDEDGOTO: u32 = 5;
pub const PDFDEST_VIEW_UNKNOWN_MODE: u32 = 0;
pub const PDFDEST_VIEW_XYZ: u32 = 1;
pub const PDFDEST_VIEW_FIT: u32 = 2;
pub const PDFDEST_VIEW_FITH: u32 = 3;
pub const PDFDEST_VIEW_FITV: u32 = 4;
pub const PDFDEST_VIEW_FITR: u32 = 5;
pub const PDFDEST_VIEW_FITB: u32 = 6;
pub const PDFDEST_VIEW_FITBH: u32 = 7;
pub const PDFDEST_VIEW_FITBV: u32 = 8;
pub const FORMTYPE_NONE: u32 = 0;
pub const FORMTYPE_ACRO_FORM: u32 = 1;
pub const FORMTYPE_XFA_FULL: u32 = 2;
pub const FORMTYPE_XFA_FOREGROUND: u32 = 3;
pub const FORMTYPE_COUNT: u32 = 4;
pub const JSPLATFORM_ALERT_BUTTON_OK: u32 = 0;
pub const JSPLATFORM_ALERT_BUTTON_OKCANCEL: u32 = 1;
pub const JSPLATFORM_ALERT_BUTTON_YESNO: u32 = 2;
pub const JSPLATFORM_ALERT_BUTTON_YESNOCANCEL: u32 = 3;
pub const JSPLATFORM_ALERT_BUTTON_DEFAULT: u32 = 0;
pub const JSPLATFORM_ALERT_ICON_ERROR: u32 = 0;
pub const JSPLATFORM_ALERT_ICON_WARNING: u32 = 1;
pub const JSPLATFORM_ALERT_ICON_QUESTION: u32 = 2;
pub const JSPLATFORM_ALERT_ICON_STATUS: u32 = 3;
pub const JSPLATFORM_ALERT_ICON_ASTERISK: u32 = 4;
pub const JSPLATFORM_ALERT_ICON_DEFAULT: u32 = 0;
pub const JSPLATFORM_ALERT_RETURN_OK: u32 = 1;
pub const JSPLATFORM_ALERT_RETURN_CANCEL: u32 = 2;
pub const JSPLATFORM_ALERT_RETURN_NO: u32 = 3;
pub const JSPLATFORM_ALERT_RETURN_YES: u32 = 4;
pub const JSPLATFORM_BEEP_ERROR: u32 = 0;
pub const JSPLATFORM_BEEP_WARNING: u32 = 1;
pub const JSPLATFORM_BEEP_QUESTION: u32 = 2;
pub const JSPLATFORM_BEEP_STATUS: u32 = 3;
pub const JSPLATFORM_BEEP_DEFAULT: u32 = 4;
pub const FXCT_ARROW: u32 = 0;
pub const FXCT_NESW: u32 = 1;
pub const FXCT_NWSE: u32 = 2;
pub const FXCT_VBEAM: u32 = 3;
pub const FXCT_HBEAM: u32 = 4;
pub const FXCT_HAND: u32 = 5;
pub const FPDFDOC_AACTION_WC: u32 = 16;
pub const FPDFDOC_AACTION_WS: u32 = 17;
pub const FPDFDOC_AACTION_DS: u32 = 18;
pub const FPDFDOC_AACTION_WP: u32 = 19;
pub const FPDFDOC_AACTION_DP: u32 = 20;
pub const FPDFPAGE_AACTION_OPEN: u32 = 0;
pub const FPDFPAGE_AACTION_CLOSE: u32 = 1;
pub const FPDF_FORMFIELD_UNKNOWN: u32 = 0;
pub const FPDF_FORMFIELD_PUSHBUTTON: u32 = 1;
pub const FPDF_FORMFIELD_CHECKBOX: u32 = 2;
pub const FPDF_FORMFIELD_RADIOBUTTON: u32 = 3;
pub const FPDF_FORMFIELD_COMBOBOX: u32 = 4;
pub const FPDF_FORMFIELD_LISTBOX: u32 = 5;
pub const FPDF_FORMFIELD_TEXTFIELD: u32 = 6;
pub const FPDF_FORMFIELD_SIGNATURE: u32 = 7;
pub const FPDF_FORMFIELD_COUNT: u32 = 8;
pub const FPDF_ANNOT_UNKNOWN: u32 = 0;
pub const FPDF_ANNOT_TEXT: u32 = 1;
pub const FPDF_ANNOT_LINK: u32 = 2;
pub const FPDF_ANNOT_FREETEXT: u32 = 3;
pub const FPDF_ANNOT_LINE: u32 = 4;
pub const FPDF_ANNOT_SQUARE: u32 = 5;
pub const FPDF_ANNOT_CIRCLE: u32 = 6;
pub const FPDF_ANNOT_POLYGON: u32 = 7;
pub const FPDF_ANNOT_POLYLINE: u32 = 8;
pub const FPDF_ANNOT_HIGHLIGHT: u32 = 9;
pub const FPDF_ANNOT_UNDERLINE: u32 = 10;
pub const FPDF_ANNOT_SQUIGGLY: u32 = 11;
pub const FPDF_ANNOT_STRIKEOUT: u32 = 12;
pub const FPDF_ANNOT_STAMP: u32 = 13;
pub const FPDF_ANNOT_CARET: u32 = 14;
pub const FPDF_ANNOT_INK: u32 = 15;
pub const FPDF_ANNOT_POPUP: u32 = 16;
pub const FPDF_ANNOT_FILEATTACHMENT: u32 = 17;
pub const FPDF_ANNOT_SOUND: u32 = 18;
pub const FPDF_ANNOT_MOVIE: u32 = 19;
pub const FPDF_ANNOT_WIDGET: u32 = 20;
pub const FPDF_ANNOT_SCREEN: u32 = 21;
pub const FPDF_ANNOT_PRINTERMARK: u32 = 22;
pub const FPDF_ANNOT_TRAPNET: u32 = 23;
pub const FPDF_ANNOT_WATERMARK: u32 = 24;
pub const FPDF_ANNOT_THREED: u32 = 25;
pub const FPDF_ANNOT_RICHMEDIA: u32 = 26;
pub const FPDF_ANNOT_XFAWIDGET: u32 = 27;
pub const FPDF_ANNOT_REDACT: u32 = 28;
pub const FPDF_ANNOT_FLAG_NONE: u32 = 0;
pub const FPDF_ANNOT_FLAG_INVISIBLE: u32 = 1;
pub const FPDF_ANNOT_FLAG_HIDDEN: u32 = 2;
pub const FPDF_ANNOT_FLAG_PRINT: u32 = 4;
pub const FPDF_ANNOT_FLAG_NOZOOM: u32 = 8;
pub const FPDF_ANNOT_FLAG_NOROTATE: u32 = 16;
pub const FPDF_ANNOT_FLAG_NOVIEW: u32 = 32;
pub const FPDF_ANNOT_FLAG_READONLY: u32 = 64;
pub const FPDF_ANNOT_FLAG_LOCKED: u32 = 128;
pub const FPDF_ANNOT_FLAG_TOGGLENOVIEW: u32 = 256;
pub const FPDF_ANNOT_APPEARANCEMODE_NORMAL: u32 = 0;
pub const FPDF_ANNOT_APPEARANCEMODE_ROLLOVER: u32 = 1;
pub const FPDF_ANNOT_APPEARANCEMODE_DOWN: u32 = 2;
pub const FPDF_ANNOT_APPEARANCEMODE_COUNT: u32 = 3;
pub const FPDF_FORMFLAG_NONE: u32 = 0;
pub const FPDF_FORMFLAG_READONLY: u32 = 1;
pub const FPDF_FORMFLAG_REQUIRED: u32 = 2;
pub const FPDF_FORMFLAG_NOEXPORT: u32 = 4;
pub const FPDF_FORMFLAG_TEXT_MULTILINE: u32 = 4096;
pub const FPDF_FORMFLAG_TEXT_PASSWORD: u32 = 8192;
pub const FPDF_FORMFLAG_CHOICE_COMBO: u32 = 131072;
pub const FPDF_FORMFLAG_CHOICE_EDIT: u32 = 262144;
pub const FPDF_FORMFLAG_CHOICE_MULTI_SELECT: u32 = 2097152;
pub const PDF_LINEARIZATION_UNKNOWN: i32 = -1;
pub const PDF_NOT_LINEARIZED: u32 = 0;
pub const PDF_LINEARIZED: u32 = 1;
pub const PDF_DATA_ERROR: i32 = -1;
pub const PDF_DATA_NOTAVAIL: u32 = 0;
pub const PDF_DATA_AVAIL: u32 = 1;
pub const PDF_FORM_ERROR: i32 = -1;
pub const PDF_FORM_NOTAVAIL: u32 = 0;
pub const PDF_FORM_AVAIL: u32 = 1;
pub const PDF_FORM_NOTEXIST: u32 = 2;
pub const FPDF_COLORSPACE_UNKNOWN: u32 = 0;
pub const FPDF_COLORSPACE_DEVICEGRAY: u32 = 1;
pub const FPDF_COLORSPACE_DEVICERGB: u32 = 2;
pub const FPDF_COLORSPACE_DEVICECMYK: u32 = 3;
pub const FPDF_COLORSPACE_CALGRAY: u32 = 4;
pub const FPDF_COLORSPACE_CALRGB: u32 = 5;
pub const FPDF_COLORSPACE_LAB: u32 = 6;
pub const FPDF_COLORSPACE_ICCBASED: u32 = 7;
pub const FPDF_COLORSPACE_SEPARATION: u32 = 8;
pub const FPDF_COLORSPACE_DEVICEN: u32 = 9;
pub const FPDF_COLORSPACE_INDEXED: u32 = 10;
pub const FPDF_COLORSPACE_PATTERN: u32 = 11;
pub const FPDF_PAGEOBJ_UNKNOWN: u32 = 0;
pub const FPDF_PAGEOBJ_TEXT: u32 = 1;
pub const FPDF_PAGEOBJ_PATH: u32 = 2;
pub const FPDF_PAGEOBJ_IMAGE: u32 = 3;
pub const FPDF_PAGEOBJ_SHADING: u32 = 4;
pub const FPDF_PAGEOBJ_FORM: u32 = 5;
pub const FPDF_SEGMENT_UNKNOWN: i32 = -1;
pub const FPDF_SEGMENT_LINETO: u32 = 0;
pub const FPDF_SEGMENT_BEZIERTO: u32 = 1;
pub const FPDF_SEGMENT_MOVETO: u32 = 2;
pub const FPDF_FILLMODE_NONE: u32 = 0;
pub const FPDF_FILLMODE_ALTERNATE: u32 = 1;
pub const FPDF_FILLMODE_WINDING: u32 = 2;
pub const FPDF_FONT_TYPE1: u32 = 1;
pub const FPDF_FONT_TRUETYPE: u32 = 2;
pub const FPDF_LINECAP_BUTT: u32 = 0;
pub const FPDF_LINECAP_ROUND: u32 = 1;
pub const FPDF_LINECAP_PROJECTING_SQUARE: u32 = 2;
pub const FPDF_LINEJOIN_MITER: u32 = 0;
pub const FPDF_LINEJOIN_ROUND: u32 = 1;
pub const FPDF_LINEJOIN_BEVEL: u32 = 2;
pub const FPDF_PRINTMODE_EMF: u32 = 0;
pub const FPDF_PRINTMODE_TEXTONLY: u32 = 1;
pub const FPDF_PRINTMODE_POSTSCRIPT2: u32 = 2;
pub const FPDF_PRINTMODE_POSTSCRIPT3: u32 = 3;
pub const FPDF_PRINTMODE_POSTSCRIPT2_PASSTHROUGH: u32 = 4;
pub const FPDF_PRINTMODE_POSTSCRIPT3_PASSTHROUGH: u32 = 5;
pub const FPDF_PRINTMODE_EMF_IMAGE_MASKS: u32 = 6;
pub const FPDF_PRINTMODE_POSTSCRIPT3_TYPE42: u32 = 7;
pub const FPDF_PRINTMODE_POSTSCRIPT3_TYPE42_PASSTHROUGH: u32 = 8;
pub const FPDF_UNSP_DOC_XFAFORM: u32 = 1;
pub const FPDF_UNSP_DOC_PORTABLECOLLECTION: u32 = 2;
pub const FPDF_UNSP_DOC_ATTACHMENT: u32 = 3;
pub const FPDF_UNSP_DOC_SECURITY: u32 = 4;
pub const FPDF_UNSP_DOC_SHAREDREVIEW: u32 = 5;
pub const FPDF_UNSP_DOC_SHAREDFORM_ACROBAT: u32 = 6;
pub const FPDF_UNSP_DOC_SHAREDFORM_FILESYSTEM: u32 = 7;
pub const FPDF_UNSP_DOC_SHAREDFORM_EMAIL: u32 = 8;
pub const FPDF_UNSP_ANNOT_3DANNOT: u32 = 11;
pub const FPDF_UNSP_ANNOT_MOVIE: u32 = 12;
pub const FPDF_UNSP_ANNOT_SOUND: u32 = 13;
pub const FPDF_UNSP_ANNOT_SCREEN_MEDIA: u32 = 14;
pub const FPDF_UNSP_ANNOT_SCREEN_RICHMEDIA: u32 = 15;
pub const FPDF_UNSP_ANNOT_ATTACHMENT: u32 = 16;
pub const FPDF_UNSP_ANNOT_SIG: u32 = 17;
pub const PAGEMODE_UNKNOWN: i32 = -1;
pub const PAGEMODE_USENONE: u32 = 0;
pub const PAGEMODE_USEOUTLINES: u32 = 1;
pub const PAGEMODE_USETHUMBS: u32 = 2;
pub const PAGEMODE_FULLSCREEN: u32 = 3;
pub const PAGEMODE_USEOC: u32 = 4;
pub const PAGEMODE_USEATTACHMENTS: u32 = 5;
pub const FLATTEN_FAIL: u32 = 0;
pub const FLATTEN_SUCCESS: u32 = 1;
pub const FLATTEN_NOTHINGTODO: u32 = 2;
pub const FLAT_NORMALDISPLAY: u32 = 0;
pub const FLAT_PRINT: u32 = 1;
pub const FPDF_RENDER_READY: u32 = 0;
pub const FPDF_RENDER_TOBECONTINUED: u32 = 1;
pub const FPDF_RENDER_DONE: u32 = 2;
pub const FPDF_RENDER_FAILED: u32 = 3;
pub const FPDF_INCREMENTAL: u32 = 1;
pub const FPDF_NO_INCREMENTAL: u32 = 2;
pub const FPDF_REMOVE_SECURITY: u32 = 3;
pub const FXFONT_ANSI_CHARSET: u32 = 0;
pub const FXFONT_DEFAULT_CHARSET: u32 = 1;
pub const FXFONT_SYMBOL_CHARSET: u32 = 2;
pub const FXFONT_SHIFTJIS_CHARSET: u32 = 128;
pub const FXFONT_HANGEUL_CHARSET: u32 = 129;
pub const FXFONT_GB2312_CHARSET: u32 = 134;
pub const FXFONT_CHINESEBIG5_CHARSET: u32 = 136;
pub const FXFONT_ARABIC_CHARSET: u32 = 178;
pub const FXFONT_CYRILLIC_CHARSET: u32 = 204;
pub const FXFONT_EASTERNEUROPEAN_CHARSET: u32 = 238;
pub const FXFONT_FF_FIXEDPITCH: u32 = 1;
pub const FXFONT_FF_ROMAN: u32 = 16;
pub const FXFONT_FF_SCRIPT: u32 = 64;
pub const FXFONT_FW_NORMAL: u32 = 400;
pub const FXFONT_FW_BOLD: u32 = 700;
pub const FPDF_MATCHCASE: u32 = 1;
pub const FPDF_MATCHWHOLEWORD: u32 = 2;
pub const FPDF_CONSECUTIVE: u32 = 4;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[doc = " Define 'max_align_t' to match the GCC definition."]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_UNKNOWN: FPDF_TEXT_RENDERMODE = -1;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL: FPDF_TEXT_RENDERMODE = 0;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_STROKE: FPDF_TEXT_RENDERMODE = 1;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_STROKE: FPDF_TEXT_RENDERMODE = 2;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_INVISIBLE: FPDF_TEXT_RENDERMODE = 3;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_CLIP: FPDF_TEXT_RENDERMODE = 4;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_STROKE_CLIP: FPDF_TEXT_RENDERMODE = 5;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_FILL_STROKE_CLIP: FPDF_TEXT_RENDERMODE = 6;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_CLIP: FPDF_TEXT_RENDERMODE = 7;
pub const FPDF_TEXT_RENDERMODE_FPDF_TEXTRENDERMODE_LAST: FPDF_TEXT_RENDERMODE = 7;
#[doc = " PDF text rendering modes"]
pub type FPDF_TEXT_RENDERMODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_action_t__ {
    _unused: [u8; 0],
}
#[doc = " PDF types - use incomplete types (never completed) to force API type safety."]
pub type FPDF_ACTION = *mut fpdf_action_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_annotation_t__ {
    _unused: [u8; 0],
}
pub type FPDF_ANNOTATION = *mut fpdf_annotation_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_attachment_t__ {
    _unused: [u8; 0],
}
pub type FPDF_ATTACHMENT = *mut fpdf_attachment_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_avail_t__ {
    _unused: [u8; 0],
}
pub type FPDF_AVAIL = *mut fpdf_avail_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_bitmap_t__ {
    _unused: [u8; 0],
}
pub type FPDF_BITMAP = *mut fpdf_bitmap_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_bookmark_t__ {
    _unused: [u8; 0],
}
pub type FPDF_BOOKMARK = *mut fpdf_bookmark_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_clippath_t__ {
    _unused: [u8; 0],
}
pub type FPDF_CLIPPATH = *mut fpdf_clippath_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_dest_t__ {
    _unused: [u8; 0],
}
pub type FPDF_DEST = *mut fpdf_dest_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_document_t__ {
    _unused: [u8; 0],
}
pub type FPDF_DOCUMENT = *mut fpdf_document_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_font_t__ {
    _unused: [u8; 0],
}
pub type FPDF_FONT = *mut fpdf_font_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_form_handle_t__ {
    _unused: [u8; 0],
}
pub type FPDF_FORMHANDLE = *mut fpdf_form_handle_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_glyphpath_t__ {
    _unused: [u8; 0],
}
pub type FPDF_GLYPHPATH = *const fpdf_glyphpath_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_javascript_action_t {
    _unused: [u8; 0],
}
pub type FPDF_JAVASCRIPT_ACTION = *mut fpdf_javascript_action_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_link_t__ {
    _unused: [u8; 0],
}
pub type FPDF_LINK = *mut fpdf_link_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_page_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGE = *mut fpdf_page_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pagelink_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGELINK = *mut fpdf_pagelink_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pageobject_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGEOBJECT = *mut fpdf_pageobject_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pageobjectmark_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGEOBJECTMARK = *mut fpdf_pageobjectmark_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pagerange_t__ {
    _unused: [u8; 0],
}
pub type FPDF_PAGERANGE = *mut fpdf_pagerange_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_pathsegment_t {
    _unused: [u8; 0],
}
pub type FPDF_PATHSEGMENT = *const fpdf_pathsegment_t;
pub type FPDF_RECORDER = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_schhandle_t__ {
    _unused: [u8; 0],
}
pub type FPDF_SCHHANDLE = *mut fpdf_schhandle_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_signature_t__ {
    _unused: [u8; 0],
}
pub type FPDF_SIGNATURE = *mut fpdf_signature_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_structelement_t__ {
    _unused: [u8; 0],
}
pub type FPDF_STRUCTELEMENT = *mut fpdf_structelement_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_structtree_t__ {
    _unused: [u8; 0],
}
pub type FPDF_STRUCTTREE = *mut fpdf_structtree_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_textpage_t__ {
    _unused: [u8; 0],
}
pub type FPDF_TEXTPAGE = *mut fpdf_textpage_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_widget_t__ {
    _unused: [u8; 0],
}
pub type FPDF_WIDGET = *mut fpdf_widget_t__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpdf_xobject_t__ {
    _unused: [u8; 0],
}
pub type FPDF_XOBJECT = *mut fpdf_xobject_t__;
#[doc = " Basic data types"]
pub type FPDF_BOOL = ::std::os::raw::c_int;
pub type FPDF_RESULT = ::std::os::raw::c_int;
pub type FPDF_DWORD = ::std::os::raw::c_ulong;
pub type FS_FLOAT = f32;
pub const _FPDF_DUPLEXTYPE__DuplexUndefined: _FPDF_DUPLEXTYPE_ = 0;
pub const _FPDF_DUPLEXTYPE__Simplex: _FPDF_DUPLEXTYPE_ = 1;
pub const _FPDF_DUPLEXTYPE__DuplexFlipShortEdge: _FPDF_DUPLEXTYPE_ = 2;
pub const _FPDF_DUPLEXTYPE__DuplexFlipLongEdge: _FPDF_DUPLEXTYPE_ = 3;
#[doc = " Duplex types"]
pub type _FPDF_DUPLEXTYPE_ = ::std::os::raw::c_uint;
#[doc = " Duplex types"]
pub use self::_FPDF_DUPLEXTYPE_ as FPDF_DUPLEXTYPE;
#[doc = " String types"]
pub type FPDF_WCHAR = ::std::os::raw::c_ushort;
#[doc = " FPDFSDK may use three types of strings: byte string, wide string (UTF-16LE"]
#[doc = " encoded), and platform dependent string"]
pub type FPDF_BYTESTRING = *const ::std::os::raw::c_char;
#[doc = " FPDFSDK always uses UTF-16LE encoded wide strings, each character uses 2"]
#[doc = " bytes (except surrogation), with the low byte first."]
pub type FPDF_WIDESTRING = *const ::std::os::raw::c_ushort;
#[doc = " Structure for persisting a string beyond the duration of a callback."]
#[doc = " Note: although represented as a char*, string may be interpreted as"]
#[doc = " a UTF-16LE formated string. Used only by XFA callbacks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_BSTR_ {
    #[doc = " String buffer, manipulate only with FPDF_BStr_* methods."]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = " Length of the string, in bytes."]
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FPDF_BSTR_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_BSTR_>(),
        8usize,
        concat!("Size of: ", stringify!(FPDF_BSTR_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_BSTR_>(),
        4usize,
        concat!("Alignment of ", stringify!(FPDF_BSTR_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_BSTR_>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_BSTR_),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_BSTR_>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_BSTR_),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " Structure for persisting a string beyond the duration of a callback."]
#[doc = " Note: although represented as a char*, string may be interpreted as"]
#[doc = " a UTF-16LE formated string. Used only by XFA callbacks."]
pub type FPDF_BSTR = FPDF_BSTR_;
#[doc = " For Windows programmers: In most cases it's OK to treat FPDF_WIDESTRING as a"]
#[doc = " Windows unicode string, however, special care needs to be taken if you"]
#[doc = " expect to process Unicode larger than 0xffff."]
#[doc = ""]
#[doc = " For Linux/Unix programmers: most compiler/library environments use 4 bytes"]
#[doc = " for a Unicode character, and you have to convert between FPDF_WIDESTRING and"]
#[doc = " system wide string by yourself."]
pub type FPDF_STRING = *const ::std::os::raw::c_char;
#[doc = " Matrix for transformation, in the form [a b c d e f], equivalent to:"]
#[doc = " | a  b  0 |"]
#[doc = " | c  d  0 |"]
#[doc = " | e  f  1 |"]
#[doc = ""]
#[doc = " Translation is performed with [1 0 0 1 tx ty]."]
#[doc = " Scaling is performed with [sx 0 0 sy 0 0]."]
#[doc = " See PDF Reference 1.7, 4.2.2 Common Transformations for more."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_MATRIX_ {
    pub a: f32,
    pub b: f32,
    pub c: f32,
    pub d: f32,
    pub e: f32,
    pub f: f32,
}
#[test]
fn bindgen_test_layout__FS_MATRIX_() {
    assert_eq!(
        ::std::mem::size_of::<_FS_MATRIX_>(),
        24usize,
        concat!("Size of: ", stringify!(_FS_MATRIX_))
    );
    assert_eq!(
        ::std::mem::align_of::<_FS_MATRIX_>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_MATRIX_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).b as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).c as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).d as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).e as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_MATRIX_>())).f as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_MATRIX_),
            "::",
            stringify!(f)
        )
    );
}
#[doc = " Matrix for transformation, in the form [a b c d e f], equivalent to:"]
#[doc = " | a  b  0 |"]
#[doc = " | c  d  0 |"]
#[doc = " | e  f  1 |"]
#[doc = ""]
#[doc = " Translation is performed with [1 0 0 1 tx ty]."]
#[doc = " Scaling is performed with [sx 0 0 sy 0 0]."]
#[doc = " See PDF Reference 1.7, 4.2.2 Common Transformations for more."]
pub type FS_MATRIX = _FS_MATRIX_;
#[doc = " Rectangle area(float) in device or page coordinate system."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_RECTF_ {
    #[doc = " The x-coordinate of the left-top corner."]
    pub left: f32,
    #[doc = " The y-coordinate of the left-top corner."]
    pub top: f32,
    #[doc = " The x-coordinate of the right-bottom corner."]
    pub right: f32,
    #[doc = " The y-coordinate of the right-bottom corner."]
    pub bottom: f32,
}
#[test]
fn bindgen_test_layout__FS_RECTF_() {
    assert_eq!(
        ::std::mem::size_of::<_FS_RECTF_>(),
        16usize,
        concat!("Size of: ", stringify!(_FS_RECTF_))
    );
    assert_eq!(
        ::std::mem::align_of::<_FS_RECTF_>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_RECTF_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).left as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).top as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).right as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_RECTF_>())).bottom as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_RECTF_),
            "::",
            stringify!(bottom)
        )
    );
}
#[doc = " Rectangle area(float) in device or page coordinate system."]
pub type FS_LPRECTF = *mut _FS_RECTF_;
#[doc = " Rectangle area(float) in device or page coordinate system."]
pub type FS_RECTF = _FS_RECTF_;
#[doc = " Const Pointer to FS_RECTF structure."]
pub type FS_LPCRECTF = *const FS_RECTF;
#[doc = " Rectangle size. Coordinate system agnostic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_SIZEF_ {
    pub width: f32,
    pub height: f32,
}
#[test]
fn bindgen_test_layout_FS_SIZEF_() {
    assert_eq!(
        ::std::mem::size_of::<FS_SIZEF_>(),
        8usize,
        concat!("Size of: ", stringify!(FS_SIZEF_))
    );
    assert_eq!(
        ::std::mem::align_of::<FS_SIZEF_>(),
        4usize,
        concat!("Alignment of ", stringify!(FS_SIZEF_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_SIZEF_>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_SIZEF_),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_SIZEF_>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_SIZEF_),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " Rectangle size. Coordinate system agnostic."]
pub type FS_LPSIZEF = *mut FS_SIZEF_;
#[doc = " Rectangle size. Coordinate system agnostic."]
pub type FS_SIZEF = FS_SIZEF_;
#[doc = " Const Pointer to FS_SIZEF structure."]
pub type FS_LPCSIZEF = *const FS_SIZEF;
#[doc = " 2D Point. Coordinate system agnostic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_POINTF_ {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_FS_POINTF_() {
    assert_eq!(
        ::std::mem::size_of::<FS_POINTF_>(),
        8usize,
        concat!("Size of: ", stringify!(FS_POINTF_))
    );
    assert_eq!(
        ::std::mem::align_of::<FS_POINTF_>(),
        4usize,
        concat!("Alignment of ", stringify!(FS_POINTF_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_POINTF_>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_POINTF_),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FS_POINTF_>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FS_POINTF_),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " 2D Point. Coordinate system agnostic."]
pub type FS_LPPOINTF = *mut FS_POINTF_;
#[doc = " 2D Point. Coordinate system agnostic."]
pub type FS_POINTF = FS_POINTF_;
#[doc = " Const Pointer to FS_POINTF structure."]
pub type FS_LPCPOINTF = *const FS_POINTF;
#[doc = " Annotation enums."]
pub type FPDF_ANNOTATION_SUBTYPE = ::std::os::raw::c_int;
pub type FPDF_ANNOT_APPEARANCEMODE = ::std::os::raw::c_int;
#[doc = " Dictionary value types."]
pub type FPDF_OBJECT_TYPE = ::std::os::raw::c_int;
#[doc = " Process-wide options for initializing the library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_LIBRARY_CONFIG_ {
    #[doc = " Version number of the interface. Currently must be 2."]
    #[doc = " Support for version 1 will be deprecated in the future."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Array of paths to scan in place of the defaults when using built-in"]
    #[doc = " FXGE font loading code. The array is terminated by a NULL pointer."]
    #[doc = " The Array may be NULL itself to use the default paths. May be ignored"]
    #[doc = " entirely depending upon the platform."]
    pub m_pUserFontPaths: *mut *const ::std::os::raw::c_char,
    #[doc = " Pointer to the v8::Isolate to use, or NULL to force PDFium to create one."]
    pub m_pIsolate: *mut ::std::os::raw::c_void,
    #[doc = " The embedder data slot to use in the v8::Isolate to store PDFium's"]
    #[doc = " per-isolate data. The value needs to be in the range"]
    #[doc = " [0, |v8::Internals::kNumIsolateDataLots|). Note that 0 is fine for most"]
    #[doc = " embedders."]
    pub m_v8EmbedderSlot: ::std::os::raw::c_uint,
    #[doc = " Pointer to the V8::Platform to use."]
    pub m_pPlatform: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FPDF_LIBRARY_CONFIG_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_LIBRARY_CONFIG_>(),
        20usize,
        concat!("Size of: ", stringify!(FPDF_LIBRARY_CONFIG_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_LIBRARY_CONFIG_>(),
        4usize,
        concat!("Alignment of ", stringify!(FPDF_LIBRARY_CONFIG_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_pUserFontPaths as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pUserFontPaths)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_pIsolate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pIsolate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_v8EmbedderSlot as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_v8EmbedderSlot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_LIBRARY_CONFIG_>())).m_pPlatform as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_LIBRARY_CONFIG_),
            "::",
            stringify!(m_pPlatform)
        )
    );
}
#[doc = " Process-wide options for initializing the library."]
pub type FPDF_LIBRARY_CONFIG = FPDF_LIBRARY_CONFIG_;
#[doc = " Structure for custom file access."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_FILEACCESS {
    #[doc = " File length, in bytes."]
    pub m_FileLen: ::std::os::raw::c_ulong,
    #[doc = " A function pointer for getting a block of data from a specific position."]
    #[doc = " Position is specified by byte offset from the beginning of the file."]
    #[doc = " The pointer to the buffer is never NULL and the size is never 0."]
    #[doc = " The position and size will never go out of range of the file length."]
    #[doc = " It may be possible for FPDFSDK to call this function multiple times for"]
    #[doc = " the same position."]
    #[doc = " Return value: should be non-zero if successful, zero for error."]
    pub m_GetBlock: ::std::option::Option<
        unsafe extern "C" fn(
            param: *mut ::std::os::raw::c_void,
            position: ::std::os::raw::c_ulong,
            pBuf: *mut ::std::os::raw::c_uchar,
            size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A custom pointer for all implementation specific data.  This pointer will"]
    #[doc = " be used as the first parameter to the m_GetBlock callback."]
    pub m_Param: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FPDF_FILEACCESS() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_FILEACCESS>(),
        12usize,
        concat!("Size of: ", stringify!(FPDF_FILEACCESS))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_FILEACCESS>(),
        4usize,
        concat!("Alignment of ", stringify!(FPDF_FILEACCESS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEACCESS>())).m_FileLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_FileLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEACCESS>())).m_GetBlock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_GetBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEACCESS>())).m_Param as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEACCESS),
            "::",
            stringify!(m_Param)
        )
    );
}
#[doc = " Structure for file reading or writing (I/O)."]
#[doc = ""]
#[doc = " Note: This is a handler and should be implemented by callers,"]
#[doc = " and is only used from XFA."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_FILEHANDLER_ {
    #[doc = " User-defined data."]
    #[doc = " Note: Callers can use this field to track controls."]
    pub clientData: *mut ::std::os::raw::c_void,
    #[doc = " Callback function to release the current file stream object."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = " Returns:"]
    #[doc = "       None."]
    pub Release:
        ::std::option::Option<unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void)>,
    #[doc = " Callback function to retrieve the current file stream size."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = " Returns:"]
    #[doc = "       Size of file stream."]
    pub GetSize: ::std::option::Option<
        unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void) -> FPDF_DWORD,
    >,
    #[doc = " Callback function to read data from the current file stream."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = "       offset       -  Offset position starts from the beginning of file"]
    #[doc = "                       stream. This parameter indicates reading position."]
    #[doc = "       buffer       -  Memory buffer to store data which are read from"]
    #[doc = "                       file stream. This parameter should not be NULL."]
    #[doc = "       size         -  Size of data which should be read from file stream,"]
    #[doc = "                       in bytes. The buffer indicated by |buffer| must be"]
    #[doc = "                       large enough to store specified data."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub ReadBlock: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            offset: FPDF_DWORD,
            buffer: *mut ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to write data into the current file stream."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = "       offset       -  Offset position starts from the beginning of file"]
    #[doc = "                       stream. This parameter indicates writing position."]
    #[doc = "       buffer       -  Memory buffer contains data which is written into"]
    #[doc = "                       file stream. This parameter should not be NULL."]
    #[doc = "       size         -  Size of data which should be written into file"]
    #[doc = "                       stream, in bytes."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub WriteBlock: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            offset: FPDF_DWORD,
            buffer: *const ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to flush all internal accessing buffers."]
    #[doc = ""]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub Flush: ::std::option::Option<
        unsafe extern "C" fn(clientData: *mut ::std::os::raw::c_void) -> FPDF_RESULT,
    >,
    #[doc = " Callback function to change file size."]
    #[doc = ""]
    #[doc = " Description:"]
    #[doc = "       This function is called under writing mode usually. Implementer"]
    #[doc = "       can determine whether to realize it based on application requests."]
    #[doc = " Parameters:"]
    #[doc = "       clientData   -  Pointer to user-defined data."]
    #[doc = "       size         -  New size of file stream, in bytes."]
    #[doc = " Returns:"]
    #[doc = "       0 for success, other value for failure."]
    pub Truncate: ::std::option::Option<
        unsafe extern "C" fn(
            clientData: *mut ::std::os::raw::c_void,
            size: FPDF_DWORD,
        ) -> FPDF_RESULT,
    >,
}
#[test]
fn bindgen_test_layout_FPDF_FILEHANDLER_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_FILEHANDLER_>(),
        28usize,
        concat!("Size of: ", stringify!(FPDF_FILEHANDLER_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_FILEHANDLER_>(),
        4usize,
        concat!("Alignment of ", stringify!(FPDF_FILEHANDLER_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).clientData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(clientData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).Release as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).GetSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(GetSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).ReadBlock as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(ReadBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).WriteBlock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(WriteBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).Flush as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEHANDLER_>())).Truncate as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEHANDLER_),
            "::",
            stringify!(Truncate)
        )
    );
}
#[doc = " Structure for file reading or writing (I/O)."]
#[doc = ""]
#[doc = " Note: This is a handler and should be implemented by callers,"]
#[doc = " and is only used from XFA."]
pub type FPDF_FILEHANDLER = FPDF_FILEHANDLER_;
#[doc = " Struct for color scheme."]
#[doc = " Each should be a 32-bit value specifying the color, in 8888 ARGB format."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_COLORSCHEME_ {
    pub path_fill_color: FPDF_DWORD,
    pub path_stroke_color: FPDF_DWORD,
    pub text_fill_color: FPDF_DWORD,
    pub text_stroke_color: FPDF_DWORD,
}
#[test]
fn bindgen_test_layout_FPDF_COLORSCHEME_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_COLORSCHEME_>(),
        16usize,
        concat!("Size of: ", stringify!(FPDF_COLORSCHEME_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_COLORSCHEME_>(),
        4usize,
        concat!("Alignment of ", stringify!(FPDF_COLORSCHEME_))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).path_fill_color as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(path_fill_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).path_stroke_color as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(path_stroke_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).text_fill_color as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(text_fill_color)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_COLORSCHEME_>())).text_stroke_color as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_COLORSCHEME_),
            "::",
            stringify!(text_stroke_color)
        )
    );
}
#[doc = " Struct for color scheme."]
#[doc = " Each should be a 32-bit value specifying the color, in 8888 ARGB format."]
pub type FPDF_COLORSCHEME = FPDF_COLORSCHEME_;
pub const FPDF_FILEIDTYPE_FILEIDTYPE_PERMANENT: FPDF_FILEIDTYPE = 0;
pub const FPDF_FILEIDTYPE_FILEIDTYPE_CHANGING: FPDF_FILEIDTYPE = 1;
#[doc = " The file identifier entry type. See section 14.4 \"File Identifiers\" of the"]
#[doc = " ISO 32000-1:2008 spec."]
pub type FPDF_FILEIDTYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_QUADPOINTSF {
    pub x1: FS_FLOAT,
    pub y1: FS_FLOAT,
    pub x2: FS_FLOAT,
    pub y2: FS_FLOAT,
    pub x3: FS_FLOAT,
    pub y3: FS_FLOAT,
    pub x4: FS_FLOAT,
    pub y4: FS_FLOAT,
}
#[test]
fn bindgen_test_layout__FS_QUADPOINTSF() {
    assert_eq!(
        ::std::mem::size_of::<_FS_QUADPOINTSF>(),
        32usize,
        concat!("Size of: ", stringify!(_FS_QUADPOINTSF))
    );
    assert_eq!(
        ::std::mem::align_of::<_FS_QUADPOINTSF>(),
        4usize,
        concat!("Alignment of ", stringify!(_FS_QUADPOINTSF))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).y1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).x2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).y2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).x3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).y3 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).x4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(x4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FS_QUADPOINTSF>())).y4 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FS_QUADPOINTSF),
            "::",
            stringify!(y4)
        )
    );
}
pub type FS_QUADPOINTSF = _FS_QUADPOINTSF;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IPDF_JsPlatform {
    #[doc = " Version number of the interface. Currently must be 2."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Method: app_alert"]
    #[doc = "       Pop up a dialog to show warning or hint."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       Msg         -   A string containing the message to be displayed."]
    #[doc = "       Title       -   The title of the dialog."]
    #[doc = "       Type        -   The type of button group, one of the"]
    #[doc = "                       JSPLATFORM_ALERT_BUTTON_* values above."]
    #[doc = "       nIcon       -   The type of the icon, one of the"]
    #[doc = "                       JSPLATFORM_ALERT_ICON_* above."]
    #[doc = " Return Value:"]
    #[doc = "       Option selected by user in dialogue, one of the"]
    #[doc = "       JSPLATFORM_ALERT_RETURN_* values above."]
    pub app_alert: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            Msg: FPDF_WIDESTRING,
            Title: FPDF_WIDESTRING,
            Type: ::std::os::raw::c_int,
            Icon: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: app_beep"]
    #[doc = "       Causes the system to play a sound."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       nType       -   The sound type, see JSPLATFORM_BEEP_TYPE_*"]
    #[doc = "                       above."]
    #[doc = " Return Value:"]
    #[doc = "       None"]
    pub app_beep: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _IPDF_JsPlatform, nType: ::std::os::raw::c_int),
    >,
    #[doc = " Method: app_response"]
    #[doc = "       Displays a dialog box containing a question and an entry field for"]
    #[doc = "       the user to reply to the question."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       Question    -   The question to be posed to the user."]
    #[doc = "       Title       -   The title of the dialog box."]
    #[doc = "       Default     -   A default value for the answer to the question. If"]
    #[doc = "                       not specified, no default value is presented."]
    #[doc = "       cLabel      -   A short string to appear in front of and on the"]
    #[doc = "                       same line as the edit text field."]
    #[doc = "       bPassword   -   If true, indicates that the user's response should"]
    #[doc = "                       be shown as asterisks (*) or bullets (?) to mask"]
    #[doc = "                       the response, which might be sensitive information."]
    #[doc = "       response    -   A string buffer allocated by PDFium, to receive the"]
    #[doc = "                       user's response."]
    #[doc = "       length      -   The length of the buffer in bytes. Currently, it is"]
    #[doc = "                       always 2048."]
    #[doc = " Return Value:"]
    #[doc = "       Number of bytes the complete user input would actually require, not"]
    #[doc = "       including trailing zeros, regardless of the value of the length"]
    #[doc = "       parameter or the presence of the response buffer."]
    #[doc = " Comments:"]
    #[doc = "       No matter on what platform, the response buffer should be always"]
    #[doc = "       written using UTF-16LE encoding. If a response buffer is"]
    #[doc = "       present and the size of the user input exceeds the capacity of the"]
    #[doc = "       buffer as specified by the length parameter, only the"]
    #[doc = "       first \"length\" bytes of the user input are to be written to the"]
    #[doc = "       buffer."]
    pub app_response: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            Question: FPDF_WIDESTRING,
            Title: FPDF_WIDESTRING,
            Default: FPDF_WIDESTRING,
            cLabel: FPDF_WIDESTRING,
            bPassword: FPDF_BOOL,
            response: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: Doc_getFilePath"]
    #[doc = "       Get the file path of the current document."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       filePath    -   The string buffer to receive the file path. Can"]
    #[doc = "                       be NULL."]
    #[doc = "       length      -   The length of the buffer, number of bytes. Can"]
    #[doc = "                       be 0."]
    #[doc = " Return Value:"]
    #[doc = "       Number of bytes the filePath consumes, including trailing zeros."]
    #[doc = " Comments:"]
    #[doc = "       The filePath should always be provided in the local encoding."]
    #[doc = "       The return value always indicated number of bytes required for"]
    #[doc = "       the buffer, even when there is no buffer specified, or the buffer"]
    #[doc = "       size is less than required. In this case, the buffer will not"]
    #[doc = "       be modified."]
    pub Doc_getFilePath: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            filePath: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: Doc_mail"]
    #[doc = "       Mails the data buffer as an attachment to all recipients, with or"]
    #[doc = "       without user interaction."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       mailData    -   Pointer to the data buffer to be sent. Can be NULL."]
    #[doc = "       length      -   The size,in bytes, of the buffer pointed by"]
    #[doc = "                       mailData parameter. Can be 0."]
    #[doc = "       bUI         -   If true, the rest of the parameters are used in a"]
    #[doc = "                       compose-new-message window that is displayed to the"]
    #[doc = "                       user. If false, the cTo parameter is required and"]
    #[doc = "                       all others are optional."]
    #[doc = "       To          -   A semicolon-delimited list of recipients for the"]
    #[doc = "                       message."]
    #[doc = "       Subject     -   The subject of the message. The length limit is"]
    #[doc = "                       64 KB."]
    #[doc = "       CC          -   A semicolon-delimited list of CC recipients for"]
    #[doc = "                       the message."]
    #[doc = "       BCC         -   A semicolon-delimited list of BCC recipients for"]
    #[doc = "                       the message."]
    #[doc = "       Msg         -   The content of the message. The length limit is"]
    #[doc = "                       64 KB."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       If the parameter mailData is NULL or length is 0, the current"]
    #[doc = "       document will be mailed as an attachment to all recipients."]
    pub Doc_mail: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            mailData: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
            bUI: FPDF_BOOL,
            To: FPDF_WIDESTRING,
            Subject: FPDF_WIDESTRING,
            CC: FPDF_WIDESTRING,
            BCC: FPDF_WIDESTRING,
            Msg: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: Doc_print"]
    #[doc = "       Prints all or a specific number of pages of the document."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis         -   Pointer to the interface structure itself."]
    #[doc = "       bUI           -   If true, will cause a UI to be presented to the"]
    #[doc = "                         user to obtain printing information and confirm"]
    #[doc = "                         the action."]
    #[doc = "       nStart        -   A 0-based index that defines the start of an"]
    #[doc = "                         inclusive range of pages."]
    #[doc = "       nEnd          -   A 0-based index that defines the end of an"]
    #[doc = "                         inclusive page range."]
    #[doc = "       bSilent       -   If true, suppresses the cancel dialog box while"]
    #[doc = "                         the document is printing. The default is false."]
    #[doc = "       bShrinkToFit  -   If true, the page is shrunk (if necessary) to"]
    #[doc = "                         fit within the imageable area of the printed page."]
    #[doc = "       bPrintAsImage -   If true, print pages as an image."]
    #[doc = "       bReverse      -   If true, print from nEnd to nStart."]
    #[doc = "       bAnnotations  -   If true (the default), annotations are"]
    #[doc = "                         printed."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    pub Doc_print: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            bUI: FPDF_BOOL,
            nStart: ::std::os::raw::c_int,
            nEnd: ::std::os::raw::c_int,
            bSilent: FPDF_BOOL,
            bShrinkToFit: FPDF_BOOL,
            bPrintAsImage: FPDF_BOOL,
            bReverse: FPDF_BOOL,
            bAnnotations: FPDF_BOOL,
        ),
    >,
    #[doc = " Method: Doc_submitForm"]
    #[doc = "       Send the form data to a specified URL."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       formData    -   Pointer to the data buffer to be sent."]
    #[doc = "       length      -   The size,in bytes, of the buffer pointed by"]
    #[doc = "                       formData parameter."]
    #[doc = "       URL         -   The URL to send to."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    pub Doc_submitForm: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            formData: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
            URL: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: Doc_gotoPage"]
    #[doc = "       Jump to a specified page."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = "       nPageNum    -   The specified page number, zero for the first page."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = ""]
    pub Doc_gotoPage: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _IPDF_JsPlatform, nPageNum: ::std::os::raw::c_int),
    >,
    #[doc = " Method: Field_browse"]
    #[doc = "       Show a file selection dialog, and return the selected file path."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       filePath    -   Pointer to the data buffer to receive the file"]
    #[doc = "                       path. Can be NULL."]
    #[doc = "       length      -   The length of the buffer, in bytes. Can be 0."]
    #[doc = " Return Value:"]
    #[doc = "       Number of bytes the filePath consumes, including trailing zeros."]
    #[doc = " Comments:"]
    #[doc = "       The filePath shoule always be provided in local encoding."]
    pub Field_browse: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _IPDF_JsPlatform,
            filePath: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Pointer to FPDF_FORMFILLINFO interface."]
    pub m_pFormfillinfo: *mut ::std::os::raw::c_void,
    #[doc = " Unused in v3, retain for compatibility."]
    pub m_isolate: *mut ::std::os::raw::c_void,
    #[doc = " Unused in v3, retain for compatibility."]
    pub m_v8EmbedderSlot: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__IPDF_JsPlatform() {
    assert_eq!(
        ::std::mem::size_of::<_IPDF_JsPlatform>(),
        52usize,
        concat!("Size of: ", stringify!(_IPDF_JsPlatform))
    );
    assert_eq!(
        ::std::mem::align_of::<_IPDF_JsPlatform>(),
        4usize,
        concat!("Alignment of ", stringify!(_IPDF_JsPlatform))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).app_alert as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(app_alert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).app_beep as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(app_beep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).app_response as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(app_response)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Doc_getFilePath as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_getFilePath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Doc_mail as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_mail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Doc_print as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_print)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Doc_submitForm as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_submitForm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Doc_gotoPage as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Doc_gotoPage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).Field_browse as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(Field_browse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IPDF_JsPlatform>())).m_pFormfillinfo as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(m_pFormfillinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IPDF_JsPlatform>())).m_isolate as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(m_isolate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IPDF_JsPlatform>())).m_v8EmbedderSlot as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IPDF_JsPlatform),
            "::",
            stringify!(m_v8EmbedderSlot)
        )
    );
}
pub type IPDF_JSPLATFORM = _IPDF_JsPlatform;
#[doc = " Function signature for the callback function passed to the FFI_SetTimer"]
#[doc = " method."]
#[doc = " Parameters:"]
#[doc = "          idEvent     -   Identifier of the timer."]
#[doc = " Return value:"]
#[doc = "          None."]
pub type TimerCallback =
    ::std::option::Option<unsafe extern "C" fn(idEvent: ::std::os::raw::c_int)>;
#[doc = " Declares of a struct type to the local system time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPDF_SYSTEMTIME {
    #[doc = " years since 1900"]
    pub wYear: ::std::os::raw::c_ushort,
    #[doc = " months since January - [0,11]"]
    pub wMonth: ::std::os::raw::c_ushort,
    #[doc = " days since Sunday - [0,6]"]
    pub wDayOfWeek: ::std::os::raw::c_ushort,
    #[doc = " day of the month - [1,31]"]
    pub wDay: ::std::os::raw::c_ushort,
    #[doc = " hours since midnight - [0,23]"]
    pub wHour: ::std::os::raw::c_ushort,
    #[doc = " minutes after the hour - [0,59]"]
    pub wMinute: ::std::os::raw::c_ushort,
    #[doc = " seconds after the minute - [0,59]"]
    pub wSecond: ::std::os::raw::c_ushort,
    #[doc = " milliseconds after the second - [0,999]"]
    pub wMilliseconds: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__FPDF_SYSTEMTIME() {
    assert_eq!(
        ::std::mem::size_of::<_FPDF_SYSTEMTIME>(),
        16usize,
        concat!("Size of: ", stringify!(_FPDF_SYSTEMTIME))
    );
    assert_eq!(
        ::std::mem::align_of::<_FPDF_SYSTEMTIME>(),
        2usize,
        concat!("Alignment of ", stringify!(_FPDF_SYSTEMTIME))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wYear as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wYear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wMonth as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wMonth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wDayOfWeek as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wDayOfWeek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wDay as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wDay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wHour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wHour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wMinute as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wMinute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wSecond as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wSecond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSTEMTIME>())).wMilliseconds as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSTEMTIME),
            "::",
            stringify!(wMilliseconds)
        )
    );
}
#[doc = " Declares of a struct type to the local system time."]
pub type FPDF_SYSTEMTIME = _FPDF_SYSTEMTIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPDF_FORMFILLINFO {
    #[doc = " Version number of the interface."]
    #[doc = " Version 1 contains stable interfaces. Version 2 has additional"]
    #[doc = " experimental interfaces."]
    #[doc = " When PDFium is built without the XFA module, version can be 1 or 2."]
    #[doc = " With version 1, only stable interfaces are called. With version 2,"]
    #[doc = " additional experimental interfaces are also called."]
    #[doc = " When PDFium is built with the XFA module, version must be 2."]
    #[doc = " All the XFA related interfaces are experimental. If PDFium is built with"]
    #[doc = " the XFA module and version 1 then none of the XFA related interfaces"]
    #[doc = " would be called. When PDFium is built with XFA module then the version"]
    #[doc = " must be 2."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Version 1. */"]
    #[doc = " Method: Release"]
    #[doc = "       Give the implementation a chance to release any resources after the"]
    #[doc = "       interface is no longer used."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       No"]
    #[doc = " Comments:"]
    #[doc = "       Called by PDFium during the final cleanup process."]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself"]
    #[doc = " Return Value:"]
    #[doc = "       None"]
    pub Release: ::std::option::Option<unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO)>,
    #[doc = " Method: FFI_Invalidate"]
    #[doc = "       Invalidate the client area within the specified rectangle."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       page        -   Handle to the page. Returned by FPDF_LoadPage()."]
    #[doc = "       left        -   Left position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       top         -   Top position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       right       -   Right position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       bottom      -   Bottom position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       All positions are measured in PDF \"user space\"."]
    #[doc = "       Implementation should call FPDF_RenderPageBitmap() for repainting"]
    #[doc = "       the specified page area."]
    pub FFI_Invalidate: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            left: f64,
            top: f64,
            right: f64,
            bottom: f64,
        ),
    >,
    #[doc = " Method: FFI_OutputSelectedRect"]
    #[doc = "       When the user selects text in form fields with the mouse, this"]
    #[doc = "       callback function will be invoked with the selected areas."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       No"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       page        -   Handle to the page. Returned by FPDF_LoadPage()/"]
    #[doc = "       left        -   Left position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       top         -   Top position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       right       -   Right position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = "       bottom      -   Bottom position of the client area in PDF page"]
    #[doc = "                       coordinates."]
    #[doc = " Return Value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       This callback function is useful for implementing special text"]
    #[doc = "       selection effects. An implementation should first record the"]
    #[doc = "       returned rectangles, then draw them one by one during the next"]
    #[doc = "       painting period. Lastly, it should remove all the recorded"]
    #[doc = "       rectangles when finished painting."]
    pub FFI_OutputSelectedRect: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            left: f64,
            top: f64,
            right: f64,
            bottom: f64,
        ),
    >,
    #[doc = " Method: FFI_SetCursor"]
    #[doc = "       Set the Cursor shape."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       nCursorType -   Cursor type, see Flags for Cursor type for details."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_SetCursor: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, nCursorType: ::std::os::raw::c_int),
    >,
    #[doc = " Method: FFI_SetTimer"]
    #[doc = "       This method installs a system timer. An interval value is specified,"]
    #[doc = "       and every time that interval elapses, the system must call into the"]
    #[doc = "       callback function with the timer ID as returned by this function."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       uElapse     -   Specifies the time-out value, in milliseconds."]
    #[doc = "       lpTimerFunc -   A pointer to the callback function-TimerCallback."]
    #[doc = " Return value:"]
    #[doc = "       The timer identifier of the new timer if the function is successful."]
    #[doc = "       An application passes this value to the FFI_KillTimer method to kill"]
    #[doc = "       the timer. Nonzero if it is successful; otherwise, it is zero."]
    pub FFI_SetTimer: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            uElapse: ::std::os::raw::c_int,
            lpTimerFunc: TimerCallback,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_KillTimer"]
    #[doc = "       This method uninstalls a system timer, as set by an earlier call to"]
    #[doc = "       FFI_SetTimer."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       nTimerID    -   The timer ID returned by FFI_SetTimer function."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_KillTimer: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, nTimerID: ::std::os::raw::c_int),
    >,
    #[doc = " Method: FFI_GetLocalTime"]
    #[doc = "       This method receives the current local time on the system."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = " Return value:"]
    #[doc = "       The local time. See FPDF_SYSTEMTIME above for details."]
    #[doc = " Note: Unused."]
    pub FFI_GetLocalTime: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO) -> FPDF_SYSTEMTIME,
    >,
    #[doc = " Method: FFI_OnChange"]
    #[doc = "       This method will be invoked to notify the implementation when the"]
    #[doc = "       value of any FormField on the document had been changed."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       no"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_OnChange: ::std::option::Option<unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO)>,
    #[doc = " Method: FFI_GetPage"]
    #[doc = "       This method receives the page handle associated with a specified"]
    #[doc = "       page index."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       document    -   Handle to document. Returned by FPDF_LoadDocument()."]
    #[doc = "       nPageIndex  -   Index number of the page. 0 for the first page."]
    #[doc = " Return value:"]
    #[doc = "       Handle to the page, as previously returned to the implementation by"]
    #[doc = "       FPDF_LoadPage()."]
    #[doc = " Comments:"]
    #[doc = "       The implementation is expected to keep track of the page handles it"]
    #[doc = "       receives from PDFium, and their mappings to page numbers. In some"]
    #[doc = "       cases, the document-level JavaScript action may refer to a page"]
    #[doc = "       which hadn't been loaded yet. To successfully run the Javascript"]
    #[doc = "       action, the implementation needs to load the page."]
    pub FFI_GetPage: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
            nPageIndex: ::std::os::raw::c_int,
        ) -> FPDF_PAGE,
    >,
    #[doc = " Method: FFI_GetCurrentPage"]
    #[doc = "       This method receives the handle to the current page."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       Yes when V8 support is present, otherwise unused."]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       document    -   Handle to document. Returned by FPDF_LoadDocument()."]
    #[doc = " Return value:"]
    #[doc = "       Handle to the page. Returned by FPDF_LoadPage()."]
    #[doc = " Comments:"]
    #[doc = "       PDFium doesn't keep keep track of the \"current page\" (e.g. the one"]
    #[doc = "       that is most visible on screen), so it must ask the embedder for"]
    #[doc = "       this information."]
    pub FFI_GetCurrentPage: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, document: FPDF_DOCUMENT) -> FPDF_PAGE,
    >,
    #[doc = " Method: FFI_GetRotation"]
    #[doc = "       This method receives currently rotation of the page view."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis       -   Pointer to the interface structure itself."]
    #[doc = "       page        -   Handle to page, as returned by FPDF_LoadPage()."]
    #[doc = " Return value:"]
    #[doc = "       A number to indicate the page rotation in 90 degree increments"]
    #[doc = "       in a clockwise direction:"]
    #[doc = "         0 - 0 degrees"]
    #[doc = "         1 - 90 degrees"]
    #[doc = "         2 - 180 degrees"]
    #[doc = "         3 - 270 degrees"]
    #[doc = " Note: Unused."]
    pub FFI_GetRotation: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_ExecuteNamedAction"]
    #[doc = "       This method will execute a named action."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       yes"]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       namedAction     -   A byte string which indicates the named action,"]
    #[doc = "                           terminated by 0."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       See the named actions description of <<PDF Reference, version 1.7>>"]
    #[doc = "       for more details."]
    pub FFI_ExecuteNamedAction: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, namedAction: FPDF_BYTESTRING),
    >,
    #[doc = " Method: FFI_SetTextFieldFocus"]
    #[doc = "       Called when a text field is getting or losing focus."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       no"]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       value           -   The string value of the form field, in UTF-16LE"]
    #[doc = "                           format."]
    #[doc = "       valueLen        -   The length of the string value. This is the"]
    #[doc = "                           number of characters, not bytes."]
    #[doc = "       is_focus        -   True if the form field is getting focus, false"]
    #[doc = "                           if the form field is losing focus."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       Only supports text fields and combobox fields."]
    pub FFI_SetTextFieldFocus: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            value: FPDF_WIDESTRING,
            valueLen: FPDF_DWORD,
            is_focus: FPDF_BOOL,
        ),
    >,
    #[doc = " Method: FFI_DoURIAction"]
    #[doc = "       Ask the implementation to navigate to a uniform resource identifier."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       No"]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       bsURI           -   A byte string which indicates the uniform"]
    #[doc = "                           resource identifier, terminated by 0."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       If the embedder is version 2 or higher and have implementation for"]
    #[doc = "       FFI_DoURIActionWithKeyboardModifier, then"]
    #[doc = "       FFI_DoURIActionWithKeyboardModifier takes precedence over"]
    #[doc = "       FFI_DoURIAction."]
    #[doc = "       See the URI actions description of <<PDF Reference, version 1.7>>"]
    #[doc = "       for more details."]
    pub FFI_DoURIAction: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_FORMFILLINFO, bsURI: FPDF_BYTESTRING),
    >,
    #[doc = " Method: FFI_DoGoToAction"]
    #[doc = "       This action changes the view to a specified destination."]
    #[doc = " Interface Version:"]
    #[doc = "       1"]
    #[doc = " Implementation Required:"]
    #[doc = "       No"]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       nPageIndex      -   The index of the PDF page."]
    #[doc = "       zoomMode        -   The zoom mode for viewing page. See below."]
    #[doc = "       fPosArray       -   The float array which carries the position info."]
    #[doc = "       sizeofArray     -   The size of float array."]
    #[doc = " PDFZoom values:"]
    #[doc = "         - XYZ = 1"]
    #[doc = "         - FITPAGE = 2"]
    #[doc = "         - FITHORZ = 3"]
    #[doc = "         - FITVERT = 4"]
    #[doc = "         - FITRECT = 5"]
    #[doc = "         - FITBBOX = 6"]
    #[doc = "         - FITBHORZ = 7"]
    #[doc = "         - FITBVERT = 8"]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       See the Destinations description of <<PDF Reference, version 1.7>>"]
    #[doc = "       in 8.2.1 for more details."]
    pub FFI_DoGoToAction: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            nPageIndex: ::std::os::raw::c_int,
            zoomMode: ::std::os::raw::c_int,
            fPosArray: *mut f32,
            sizeofArray: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Pointer to IPDF_JSPLATFORM interface."]
    #[doc = " Unused if PDFium is built without V8 support. Otherwise, if NULL, then"]
    #[doc = " JavaScript will be prevented from executing while rendering the document."]
    pub m_pJsPlatform: *mut IPDF_JSPLATFORM,
    #[doc = " Version 2 - Experimental. */"]
    #[doc = " Whether the XFA module is disabled when built with the XFA module."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    pub xfa_disabled: FPDF_BOOL,
    #[doc = " Method: FFI_DisplayCaret"]
    #[doc = "       This method will show the caret at specified position."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       page            -   Handle to page. Returned by FPDF_LoadPage()."]
    #[doc = "       left            -   Left position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = "       top             -   Top position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = "       right           -   Right position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = "       bottom          -   Bottom position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_DisplayCaret: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            bVisible: FPDF_BOOL,
            left: f64,
            top: f64,
            right: f64,
            bottom: f64,
        ),
    >,
    #[doc = " Method: FFI_GetCurrentPageIndex"]
    #[doc = "       This method will get the current page index."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       document        -   Handle to document from FPDF_LoadDocument()."]
    #[doc = " Return value:"]
    #[doc = "       The index of current page."]
    pub FFI_GetCurrentPageIndex: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_SetCurrentPage"]
    #[doc = "       This method will set the current page."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       document        -   Handle to document from FPDF_LoadDocument()."]
    #[doc = "       iCurPage        -   The index of the PDF page."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_SetCurrentPage: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
            iCurPage: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Method: FFI_GotoURL"]
    #[doc = "       This method will navigate to the specified URL."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis            -   Pointer to the interface structure itself."]
    #[doc = "       document         -   Handle to document from FPDF_LoadDocument()."]
    #[doc = "       wsURL            -   The string value of the URL, in UTF-16LE format."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_GotoURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            document: FPDF_DOCUMENT,
            wsURL: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: FFI_GetPageViewRect"]
    #[doc = "       This method will get the current page view rectangle."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       page            -   Handle to page. Returned by FPDF_LoadPage()."]
    #[doc = "       left            -   The pointer to receive left position of the page"]
    #[doc = "                           view area in PDF page coordinates."]
    #[doc = "       top             -   The pointer to receive top position of the page"]
    #[doc = "                           view area in PDF page coordinates."]
    #[doc = "       right           -   The pointer to receive right position of the"]
    #[doc = "                           page view area in PDF page coordinates."]
    #[doc = "       bottom          -   The pointer to receive bottom position of the"]
    #[doc = "                           page view area in PDF page coordinates."]
    #[doc = " Return value:"]
    #[doc = "     None."]
    pub FFI_GetPageViewRect: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            left: *mut f64,
            top: *mut f64,
            right: *mut f64,
            bottom: *mut f64,
        ),
    >,
    #[doc = " Method: FFI_PageEvent"]
    #[doc = "       This method fires when pages have been added to or deleted from"]
    #[doc = "       the XFA document."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       page_count      -   The number of pages to be added or deleted."]
    #[doc = "       event_type      -   See FXFA_PAGEVIEWEVENT_* above."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       The pages to be added or deleted always start from the last page"]
    #[doc = "       of document. This means that if parameter page_count is 2 and"]
    #[doc = "       event type is FXFA_PAGEVIEWEVENT_POSTADDED, 2 new pages have been"]
    #[doc = "       appended to the tail of document; If page_count is 2 and"]
    #[doc = "       event type is FXFA_PAGEVIEWEVENT_POSTREMOVED, the last 2 pages"]
    #[doc = "       have been deleted."]
    pub FFI_PageEvent: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page_count: ::std::os::raw::c_int,
            event_type: FPDF_DWORD,
        ),
    >,
    #[doc = " Method: FFI_PopupMenu"]
    #[doc = "       This method will track the right context menu for XFA fields."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       page            -   Handle to page. Returned by FPDF_LoadPage()."]
    #[doc = "       hWidget         -   Always null, exists for compatibility."]
    #[doc = "       menuFlag        -   The menu flags. Please refer to macro definition"]
    #[doc = "                           of FXFA_MENU_XXX and this can be one or a"]
    #[doc = "                           combination of these macros."]
    #[doc = "       x               -   X position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = "       y               -   Y position of the client area in PDF page"]
    #[doc = "                           coordinates."]
    #[doc = " Return value:"]
    #[doc = "       TRUE indicates success; otherwise false."]
    pub FFI_PopupMenu: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            page: FPDF_PAGE,
            hWidget: FPDF_WIDGET,
            menuFlag: ::std::os::raw::c_int,
            x: f32,
            y: f32,
        ) -> FPDF_BOOL,
    >,
    #[doc = " Method: FFI_OpenFile"]
    #[doc = "       This method will open the specified file with the specified mode."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       fileFlag        -   The file flag. Please refer to macro definition"]
    #[doc = "                           of FXFA_SAVEAS_XXX and use one of these macros."]
    #[doc = "       wsURL           -   The string value of the file URL, in UTF-16LE"]
    #[doc = "                           format."]
    #[doc = "       mode            -   The mode for open file, e.g. \"rb\" or \"wb\"."]
    #[doc = " Return value:"]
    #[doc = "       The handle to FPDF_FILEHANDLER."]
    pub FFI_OpenFile: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            fileFlag: ::std::os::raw::c_int,
            wsURL: FPDF_WIDESTRING,
            mode: *const ::std::os::raw::c_char,
        ) -> *mut FPDF_FILEHANDLER,
    >,
    #[doc = " Method: FFI_EmailTo"]
    #[doc = "       This method will email the specified file stream to the specified"]
    #[doc = "       contact."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       pFileHandler    -   Handle to the FPDF_FILEHANDLER."]
    #[doc = "       pTo             -   A semicolon-delimited list of recipients for the"]
    #[doc = "                           message,in UTF-16LE format."]
    #[doc = "       pSubject        -   The subject of the message,in UTF-16LE format."]
    #[doc = "       pCC             -   A semicolon-delimited list of CC recipients for"]
    #[doc = "                           the message,in UTF-16LE format."]
    #[doc = "       pBcc            -   A semicolon-delimited list of BCC recipients for"]
    #[doc = "                           the message,in UTF-16LE format."]
    #[doc = "       pMsg            -   Pointer to the data buffer to be sent.Can be"]
    #[doc = "                           NULL,in UTF-16LE format."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_EmailTo: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            fileHandler: *mut FPDF_FILEHANDLER,
            pTo: FPDF_WIDESTRING,
            pSubject: FPDF_WIDESTRING,
            pCC: FPDF_WIDESTRING,
            pBcc: FPDF_WIDESTRING,
            pMsg: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: FFI_UploadTo"]
    #[doc = "       This method will upload the specified file stream to the"]
    #[doc = "       specified URL."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       pFileHandler    -   Handle to the FPDF_FILEHANDLER."]
    #[doc = "       fileFlag        -   The file flag. Please refer to macro definition"]
    #[doc = "                           of FXFA_SAVEAS_XXX and use one of these macros."]
    #[doc = "       uploadTo        -   Pointer to the URL path, in UTF-16LE format."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    pub FFI_UploadTo: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            fileHandler: *mut FPDF_FILEHANDLER,
            fileFlag: ::std::os::raw::c_int,
            uploadTo: FPDF_WIDESTRING,
        ),
    >,
    #[doc = " Method: FFI_GetPlatform"]
    #[doc = "       This method will get the current platform."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       platform        -   Pointer to the data buffer to receive the"]
    #[doc = "                           platform,in UTF-16LE format. Can be NULL."]
    #[doc = "       length          -   The length of the buffer in bytes. Can be"]
    #[doc = "                           0 to query the required size."]
    #[doc = " Return value:"]
    #[doc = "       The length of the buffer, number of bytes."]
    pub FFI_GetPlatform: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            platform: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_GetLanguage"]
    #[doc = "       This method will get the current language."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       language        -   Pointer to the data buffer to receive the"]
    #[doc = "                           current language. Can be NULL."]
    #[doc = "       length          -   The length of the buffer in bytes. Can be"]
    #[doc = "                           0 to query the required size."]
    #[doc = " Return value:"]
    #[doc = "       The length of the buffer, number of bytes."]
    pub FFI_GetLanguage: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            language: *mut ::std::os::raw::c_void,
            length: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: FFI_DownloadFromURL"]
    #[doc = "       This method will download the specified file from the URL."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       URL             -   The string value of the file URL, in UTF-16LE"]
    #[doc = "                           format."]
    #[doc = " Return value:"]
    #[doc = "       The handle to FPDF_FILEHANDLER."]
    pub FFI_DownloadFromURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            URL: FPDF_WIDESTRING,
        ) -> *mut FPDF_FILEHANDLER,
    >,
    #[doc = " Method: FFI_PostRequestURL"]
    #[doc = "       This method will post the request to the server URL."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       wsURL           -   The string value of the server URL, in UTF-16LE"]
    #[doc = "                           format."]
    #[doc = "       wsData          -   The post data,in UTF-16LE format."]
    #[doc = "       wsContentType   -   The content type of the request data, in"]
    #[doc = "                           UTF-16LE format."]
    #[doc = "       wsEncode        -   The encode type, in UTF-16LE format."]
    #[doc = "       wsHeader        -   The request header,in UTF-16LE format."]
    #[doc = "       response        -   Pointer to the FPDF_BSTR to receive the response"]
    #[doc = "                           data from the server, in UTF-16LE format."]
    #[doc = " Return value:"]
    #[doc = "       TRUE indicates success, otherwise FALSE."]
    pub FFI_PostRequestURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            wsURL: FPDF_WIDESTRING,
            wsData: FPDF_WIDESTRING,
            wsContentType: FPDF_WIDESTRING,
            wsEncode: FPDF_WIDESTRING,
            wsHeader: FPDF_WIDESTRING,
            response: *mut FPDF_BSTR,
        ) -> FPDF_BOOL,
    >,
    #[doc = " Method: FFI_PutRequestURL"]
    #[doc = "       This method will put the request to the server URL."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       Required for XFA, otherwise set to NULL."]
    #[doc = " Parameters:"]
    #[doc = "       pThis           -   Pointer to the interface structure itself."]
    #[doc = "       wsURL           -   The string value of the server URL, in UTF-16LE"]
    #[doc = "                           format."]
    #[doc = "       wsData          -   The put data, in UTF-16LE format."]
    #[doc = "       wsEncode        -   The encode type, in UTR-16LE format."]
    #[doc = " Return value:"]
    #[doc = "       TRUE indicates success, otherwise FALSE."]
    pub FFI_PutRequestURL: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_FORMFILLINFO,
            wsURL: FPDF_WIDESTRING,
            wsData: FPDF_WIDESTRING,
            wsEncode: FPDF_WIDESTRING,
        ) -> FPDF_BOOL,
    >,
    #[doc = " Method: FFI_OnFocusChange"]
    #[doc = "     Called when the focused annotation is updated."]
    #[doc = " Interface Version:"]
    #[doc = "     Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "     No"]
    #[doc = " Parameters:"]
    #[doc = "     param           -   Pointer to the interface structure itself."]
    #[doc = "     annot           -   The focused annotation."]
    #[doc = "     page_index      -   Index number of the page which contains the"]
    #[doc = "                         focused annotation. 0 for the first page."]
    #[doc = " Return value:"]
    #[doc = "     None."]
    #[doc = " Comments:"]
    #[doc = "     This callback function is useful for implementing any view based"]
    #[doc = "     action such as scrolling the annotation rect into view. The"]
    #[doc = "     embedder should not copy and store the annot as its scope is"]
    #[doc = "     limited to this call only."]
    pub FFI_OnFocusChange: ::std::option::Option<
        unsafe extern "C" fn(
            param: *mut _FPDF_FORMFILLINFO,
            annot: FPDF_ANNOTATION,
            page_index: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Method: FFI_DoURIActionWithKeyboardModifier"]
    #[doc = "       Ask the implementation to navigate to a uniform resource identifier"]
    #[doc = "       with the specified modifiers."]
    #[doc = " Interface Version:"]
    #[doc = "       Ignored if |version| < 2."]
    #[doc = " Implementation Required:"]
    #[doc = "       No"]
    #[doc = " Parameters:"]
    #[doc = "       param           -   Pointer to the interface structure itself."]
    #[doc = "       uri             -   A byte string which indicates the uniform"]
    #[doc = "                           resource identifier, terminated by 0."]
    #[doc = "       modifiers       -   Keyboard modifier that indicates which of"]
    #[doc = "                           the virtual keys are down, if any."]
    #[doc = " Return value:"]
    #[doc = "       None."]
    #[doc = " Comments:"]
    #[doc = "       If the embedder who is version 2 and does not implement this API,"]
    #[doc = "       then a call will be redirected to FFI_DoURIAction."]
    #[doc = "       See the URI actions description of <<PDF Reference, version 1.7>>"]
    #[doc = "       for more details."]
    pub FFI_DoURIActionWithKeyboardModifier: ::std::option::Option<
        unsafe extern "C" fn(
            param: *mut _FPDF_FORMFILLINFO,
            uri: FPDF_BYTESTRING,
            modifiers: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__FPDF_FORMFILLINFO() {
    assert_eq!(
        ::std::mem::size_of::<_FPDF_FORMFILLINFO>(),
        140usize,
        concat!("Size of: ", stringify!(_FPDF_FORMFILLINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_FPDF_FORMFILLINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_FPDF_FORMFILLINFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).Release as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(Release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_Invalidate as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_Invalidate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_OutputSelectedRect as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OutputSelectedRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_SetCursor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetCursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_SetTimer as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetTimer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_KillTimer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_KillTimer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetLocalTime as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetLocalTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_OnChange as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OnChange)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetPage as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetPage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetCurrentPage as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetCurrentPage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetRotation as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetRotation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_ExecuteNamedAction as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_ExecuteNamedAction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_SetTextFieldFocus as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetTextFieldFocus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_DoURIAction as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DoURIAction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_DoGoToAction as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DoGoToAction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).m_pJsPlatform as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(m_pJsPlatform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).xfa_disabled as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(xfa_disabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_DisplayCaret as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DisplayCaret)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetCurrentPageIndex as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetCurrentPageIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_SetCurrentPage as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_SetCurrentPage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GotoURL as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GotoURL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetPageViewRect as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetPageViewRect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_PageEvent as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PageEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_PopupMenu as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PopupMenu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_OpenFile as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OpenFile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_EmailTo as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_EmailTo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_UploadTo as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_UploadTo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetPlatform as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetPlatform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_GetLanguage as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_GetLanguage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_DownloadFromURL as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DownloadFromURL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_PostRequestURL as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PostRequestURL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_PutRequestURL as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_PutRequestURL)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_OnFocusChange as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_OnFocusChange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_FORMFILLINFO>())).FFI_DoURIActionWithKeyboardModifier
                as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_FORMFILLINFO),
            "::",
            stringify!(FFI_DoURIActionWithKeyboardModifier)
        )
    );
}
pub type FPDF_FORMFILLINFO = _FPDF_FORMFILLINFO;
pub const FPDFANNOT_COLORTYPE_FPDFANNOT_COLORTYPE_Color: FPDFANNOT_COLORTYPE = 0;
pub const FPDFANNOT_COLORTYPE_FPDFANNOT_COLORTYPE_InteriorColor: FPDFANNOT_COLORTYPE = 1;
pub type FPDFANNOT_COLORTYPE = ::std::os::raw::c_uint;
#[doc = " Interface for checking whether sections of the file are available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FX_FILEAVAIL {
    #[doc = " Version number of the interface. Must be 1."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Reports if the specified data section is currently available. A section is"]
    #[doc = " available if all bytes in the section are available."]
    #[doc = ""]
    #[doc = " Interface Version: 1"]
    #[doc = " Implementation Required: Yes"]
    #[doc = ""]
    #[doc = "   pThis  - pointer to the interface structure."]
    #[doc = "   offset - the offset of the data section in the file."]
    #[doc = "   size   - the size of the data section."]
    #[doc = ""]
    #[doc = " Returns true if the specified data section at |offset| of |size|"]
    #[doc = " is available."]
    pub IsDataAvail: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FX_FILEAVAIL, offset: size_t, size: size_t) -> FPDF_BOOL,
    >,
}
#[test]
fn bindgen_test_layout__FX_FILEAVAIL() {
    assert_eq!(
        ::std::mem::size_of::<_FX_FILEAVAIL>(),
        8usize,
        concat!("Size of: ", stringify!(_FX_FILEAVAIL))
    );
    assert_eq!(
        ::std::mem::align_of::<_FX_FILEAVAIL>(),
        4usize,
        concat!("Alignment of ", stringify!(_FX_FILEAVAIL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FX_FILEAVAIL>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FX_FILEAVAIL),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FX_FILEAVAIL>())).IsDataAvail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FX_FILEAVAIL),
            "::",
            stringify!(IsDataAvail)
        )
    );
}
#[doc = " Interface for checking whether sections of the file are available."]
pub type FX_FILEAVAIL = _FX_FILEAVAIL;
#[doc = " Download hints interface. Used to receive hints for further downloading."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FX_DOWNLOADHINTS {
    #[doc = " Version number of the interface. Must be 1."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Add a section to be downloaded."]
    #[doc = ""]
    #[doc = " Interface Version: 1"]
    #[doc = " Implementation Required: Yes"]
    #[doc = ""]
    #[doc = "   pThis  - pointer to the interface structure."]
    #[doc = "   offset - the offset of the hint reported to be downloaded."]
    #[doc = "   size   - the size of the hint reported to be downloaded."]
    #[doc = ""]
    #[doc = " The |offset| and |size| of the section may not be unique. Part of the"]
    #[doc = " section might be already available. The download manager must deal with"]
    #[doc = " overlapping sections."]
    pub AddSegment: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FX_DOWNLOADHINTS, offset: size_t, size: size_t),
    >,
}
#[test]
fn bindgen_test_layout__FX_DOWNLOADHINTS() {
    assert_eq!(
        ::std::mem::size_of::<_FX_DOWNLOADHINTS>(),
        8usize,
        concat!("Size of: ", stringify!(_FX_DOWNLOADHINTS))
    );
    assert_eq!(
        ::std::mem::align_of::<_FX_DOWNLOADHINTS>(),
        4usize,
        concat!("Alignment of ", stringify!(_FX_DOWNLOADHINTS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FX_DOWNLOADHINTS>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FX_DOWNLOADHINTS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FX_DOWNLOADHINTS>())).AddSegment as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FX_DOWNLOADHINTS),
            "::",
            stringify!(AddSegment)
        )
    );
}
#[doc = " Download hints interface. Used to receive hints for further downloading."]
pub type FX_DOWNLOADHINTS = _FX_DOWNLOADHINTS;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
#[doc = " C99 7.18.1.5 Greatest-width integer types."]
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_IMAGEOBJ_METADATA {
    #[doc = " The image width in pixels."]
    pub width: ::std::os::raw::c_uint,
    #[doc = " The image height in pixels."]
    pub height: ::std::os::raw::c_uint,
    #[doc = " The image's horizontal pixel-per-inch."]
    pub horizontal_dpi: f32,
    #[doc = " The image's vertical pixel-per-inch."]
    pub vertical_dpi: f32,
    #[doc = " The number of bits used to represent each pixel."]
    pub bits_per_pixel: ::std::os::raw::c_uint,
    #[doc = " The image's colorspace. See above for the list of FPDF_COLORSPACE_*."]
    pub colorspace: ::std::os::raw::c_int,
    #[doc = " The image's marked content ID. Useful for pairing with associated alt-text."]
    #[doc = " A value of -1 indicates no ID."]
    pub marked_content_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FPDF_IMAGEOBJ_METADATA() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_IMAGEOBJ_METADATA>(),
        28usize,
        concat!("Size of: ", stringify!(FPDF_IMAGEOBJ_METADATA))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_IMAGEOBJ_METADATA>(),
        4usize,
        concat!("Alignment of ", stringify!(FPDF_IMAGEOBJ_METADATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).horizontal_dpi as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(horizontal_dpi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).vertical_dpi as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(vertical_dpi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).bits_per_pixel as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).colorspace as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<FPDF_IMAGEOBJ_METADATA>())).marked_content_id as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_IMAGEOBJ_METADATA),
            "::",
            stringify!(marked_content_id)
        )
    );
}
#[doc = " Interface for unsupported feature notifications."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNSUPPORT_INFO {
    #[doc = " Version number of the interface. Must be 1."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Unsupported object notification function."]
    #[doc = " Interface Version: 1"]
    #[doc = " Implementation Required: Yes"]
    #[doc = ""]
    #[doc = "   pThis - pointer to the interface structure."]
    #[doc = "   nType - the type of unsupported object. One of the |FPDF_UNSP_*| entries."]
    pub FSDK_UnSupport_Handler: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _UNSUPPORT_INFO, nType: ::std::os::raw::c_int),
    >,
}
#[test]
fn bindgen_test_layout__UNSUPPORT_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_UNSUPPORT_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(_UNSUPPORT_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_UNSUPPORT_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_UNSUPPORT_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_UNSUPPORT_INFO>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNSUPPORT_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_UNSUPPORT_INFO>())).FSDK_UnSupport_Handler as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNSUPPORT_INFO),
            "::",
            stringify!(FSDK_UnSupport_Handler)
        )
    );
}
#[doc = " Interface for unsupported feature notifications."]
pub type UNSUPPORT_INFO = _UNSUPPORT_INFO;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_ShiftKey: FWL_EVENTFLAG = 1;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_ControlKey: FWL_EVENTFLAG = 2;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_AltKey: FWL_EVENTFLAG = 4;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_MetaKey: FWL_EVENTFLAG = 8;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_KeyPad: FWL_EVENTFLAG = 16;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_AutoRepeat: FWL_EVENTFLAG = 32;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_LeftButtonDown: FWL_EVENTFLAG = 64;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_MiddleButtonDown: FWL_EVENTFLAG = 128;
pub const FWL_EVENTFLAG_FWL_EVENTFLAG_RightButtonDown: FWL_EVENTFLAG = 256;
#[doc = " Key flags."]
pub type FWL_EVENTFLAG = ::std::os::raw::c_uint;
pub const FWL_VKEYCODE_FWL_VKEY_Back: FWL_VKEYCODE = 8;
pub const FWL_VKEYCODE_FWL_VKEY_Tab: FWL_VKEYCODE = 9;
pub const FWL_VKEYCODE_FWL_VKEY_NewLine: FWL_VKEYCODE = 10;
pub const FWL_VKEYCODE_FWL_VKEY_Clear: FWL_VKEYCODE = 12;
pub const FWL_VKEYCODE_FWL_VKEY_Return: FWL_VKEYCODE = 13;
pub const FWL_VKEYCODE_FWL_VKEY_Shift: FWL_VKEYCODE = 16;
pub const FWL_VKEYCODE_FWL_VKEY_Control: FWL_VKEYCODE = 17;
pub const FWL_VKEYCODE_FWL_VKEY_Menu: FWL_VKEYCODE = 18;
pub const FWL_VKEYCODE_FWL_VKEY_Pause: FWL_VKEYCODE = 19;
pub const FWL_VKEYCODE_FWL_VKEY_Capital: FWL_VKEYCODE = 20;
pub const FWL_VKEYCODE_FWL_VKEY_Kana: FWL_VKEYCODE = 21;
pub const FWL_VKEYCODE_FWL_VKEY_Hangul: FWL_VKEYCODE = 21;
pub const FWL_VKEYCODE_FWL_VKEY_Junja: FWL_VKEYCODE = 23;
pub const FWL_VKEYCODE_FWL_VKEY_Final: FWL_VKEYCODE = 24;
pub const FWL_VKEYCODE_FWL_VKEY_Hanja: FWL_VKEYCODE = 25;
pub const FWL_VKEYCODE_FWL_VKEY_Kanji: FWL_VKEYCODE = 25;
pub const FWL_VKEYCODE_FWL_VKEY_Escape: FWL_VKEYCODE = 27;
pub const FWL_VKEYCODE_FWL_VKEY_Convert: FWL_VKEYCODE = 28;
pub const FWL_VKEYCODE_FWL_VKEY_NonConvert: FWL_VKEYCODE = 29;
pub const FWL_VKEYCODE_FWL_VKEY_Accept: FWL_VKEYCODE = 30;
pub const FWL_VKEYCODE_FWL_VKEY_ModeChange: FWL_VKEYCODE = 31;
pub const FWL_VKEYCODE_FWL_VKEY_Space: FWL_VKEYCODE = 32;
pub const FWL_VKEYCODE_FWL_VKEY_Prior: FWL_VKEYCODE = 33;
pub const FWL_VKEYCODE_FWL_VKEY_Next: FWL_VKEYCODE = 34;
pub const FWL_VKEYCODE_FWL_VKEY_End: FWL_VKEYCODE = 35;
pub const FWL_VKEYCODE_FWL_VKEY_Home: FWL_VKEYCODE = 36;
pub const FWL_VKEYCODE_FWL_VKEY_Left: FWL_VKEYCODE = 37;
pub const FWL_VKEYCODE_FWL_VKEY_Up: FWL_VKEYCODE = 38;
pub const FWL_VKEYCODE_FWL_VKEY_Right: FWL_VKEYCODE = 39;
pub const FWL_VKEYCODE_FWL_VKEY_Down: FWL_VKEYCODE = 40;
pub const FWL_VKEYCODE_FWL_VKEY_Select: FWL_VKEYCODE = 41;
pub const FWL_VKEYCODE_FWL_VKEY_Print: FWL_VKEYCODE = 42;
pub const FWL_VKEYCODE_FWL_VKEY_Execute: FWL_VKEYCODE = 43;
pub const FWL_VKEYCODE_FWL_VKEY_Snapshot: FWL_VKEYCODE = 44;
pub const FWL_VKEYCODE_FWL_VKEY_Insert: FWL_VKEYCODE = 45;
pub const FWL_VKEYCODE_FWL_VKEY_Delete: FWL_VKEYCODE = 46;
pub const FWL_VKEYCODE_FWL_VKEY_Help: FWL_VKEYCODE = 47;
pub const FWL_VKEYCODE_FWL_VKEY_0: FWL_VKEYCODE = 48;
pub const FWL_VKEYCODE_FWL_VKEY_1: FWL_VKEYCODE = 49;
pub const FWL_VKEYCODE_FWL_VKEY_2: FWL_VKEYCODE = 50;
pub const FWL_VKEYCODE_FWL_VKEY_3: FWL_VKEYCODE = 51;
pub const FWL_VKEYCODE_FWL_VKEY_4: FWL_VKEYCODE = 52;
pub const FWL_VKEYCODE_FWL_VKEY_5: FWL_VKEYCODE = 53;
pub const FWL_VKEYCODE_FWL_VKEY_6: FWL_VKEYCODE = 54;
pub const FWL_VKEYCODE_FWL_VKEY_7: FWL_VKEYCODE = 55;
pub const FWL_VKEYCODE_FWL_VKEY_8: FWL_VKEYCODE = 56;
pub const FWL_VKEYCODE_FWL_VKEY_9: FWL_VKEYCODE = 57;
pub const FWL_VKEYCODE_FWL_VKEY_A: FWL_VKEYCODE = 65;
pub const FWL_VKEYCODE_FWL_VKEY_B: FWL_VKEYCODE = 66;
pub const FWL_VKEYCODE_FWL_VKEY_C: FWL_VKEYCODE = 67;
pub const FWL_VKEYCODE_FWL_VKEY_D: FWL_VKEYCODE = 68;
pub const FWL_VKEYCODE_FWL_VKEY_E: FWL_VKEYCODE = 69;
pub const FWL_VKEYCODE_FWL_VKEY_F: FWL_VKEYCODE = 70;
pub const FWL_VKEYCODE_FWL_VKEY_G: FWL_VKEYCODE = 71;
pub const FWL_VKEYCODE_FWL_VKEY_H: FWL_VKEYCODE = 72;
pub const FWL_VKEYCODE_FWL_VKEY_I: FWL_VKEYCODE = 73;
pub const FWL_VKEYCODE_FWL_VKEY_J: FWL_VKEYCODE = 74;
pub const FWL_VKEYCODE_FWL_VKEY_K: FWL_VKEYCODE = 75;
pub const FWL_VKEYCODE_FWL_VKEY_L: FWL_VKEYCODE = 76;
pub const FWL_VKEYCODE_FWL_VKEY_M: FWL_VKEYCODE = 77;
pub const FWL_VKEYCODE_FWL_VKEY_N: FWL_VKEYCODE = 78;
pub const FWL_VKEYCODE_FWL_VKEY_O: FWL_VKEYCODE = 79;
pub const FWL_VKEYCODE_FWL_VKEY_P: FWL_VKEYCODE = 80;
pub const FWL_VKEYCODE_FWL_VKEY_Q: FWL_VKEYCODE = 81;
pub const FWL_VKEYCODE_FWL_VKEY_R: FWL_VKEYCODE = 82;
pub const FWL_VKEYCODE_FWL_VKEY_S: FWL_VKEYCODE = 83;
pub const FWL_VKEYCODE_FWL_VKEY_T: FWL_VKEYCODE = 84;
pub const FWL_VKEYCODE_FWL_VKEY_U: FWL_VKEYCODE = 85;
pub const FWL_VKEYCODE_FWL_VKEY_V: FWL_VKEYCODE = 86;
pub const FWL_VKEYCODE_FWL_VKEY_W: FWL_VKEYCODE = 87;
pub const FWL_VKEYCODE_FWL_VKEY_X: FWL_VKEYCODE = 88;
pub const FWL_VKEYCODE_FWL_VKEY_Y: FWL_VKEYCODE = 89;
pub const FWL_VKEYCODE_FWL_VKEY_Z: FWL_VKEYCODE = 90;
pub const FWL_VKEYCODE_FWL_VKEY_LWin: FWL_VKEYCODE = 91;
pub const FWL_VKEYCODE_FWL_VKEY_Command: FWL_VKEYCODE = 91;
pub const FWL_VKEYCODE_FWL_VKEY_RWin: FWL_VKEYCODE = 92;
pub const FWL_VKEYCODE_FWL_VKEY_Apps: FWL_VKEYCODE = 93;
pub const FWL_VKEYCODE_FWL_VKEY_Sleep: FWL_VKEYCODE = 95;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad0: FWL_VKEYCODE = 96;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad1: FWL_VKEYCODE = 97;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad2: FWL_VKEYCODE = 98;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad3: FWL_VKEYCODE = 99;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad4: FWL_VKEYCODE = 100;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad5: FWL_VKEYCODE = 101;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad6: FWL_VKEYCODE = 102;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad7: FWL_VKEYCODE = 103;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad8: FWL_VKEYCODE = 104;
pub const FWL_VKEYCODE_FWL_VKEY_NumPad9: FWL_VKEYCODE = 105;
pub const FWL_VKEYCODE_FWL_VKEY_Multiply: FWL_VKEYCODE = 106;
pub const FWL_VKEYCODE_FWL_VKEY_Add: FWL_VKEYCODE = 107;
pub const FWL_VKEYCODE_FWL_VKEY_Separator: FWL_VKEYCODE = 108;
pub const FWL_VKEYCODE_FWL_VKEY_Subtract: FWL_VKEYCODE = 109;
pub const FWL_VKEYCODE_FWL_VKEY_Decimal: FWL_VKEYCODE = 110;
pub const FWL_VKEYCODE_FWL_VKEY_Divide: FWL_VKEYCODE = 111;
pub const FWL_VKEYCODE_FWL_VKEY_F1: FWL_VKEYCODE = 112;
pub const FWL_VKEYCODE_FWL_VKEY_F2: FWL_VKEYCODE = 113;
pub const FWL_VKEYCODE_FWL_VKEY_F3: FWL_VKEYCODE = 114;
pub const FWL_VKEYCODE_FWL_VKEY_F4: FWL_VKEYCODE = 115;
pub const FWL_VKEYCODE_FWL_VKEY_F5: FWL_VKEYCODE = 116;
pub const FWL_VKEYCODE_FWL_VKEY_F6: FWL_VKEYCODE = 117;
pub const FWL_VKEYCODE_FWL_VKEY_F7: FWL_VKEYCODE = 118;
pub const FWL_VKEYCODE_FWL_VKEY_F8: FWL_VKEYCODE = 119;
pub const FWL_VKEYCODE_FWL_VKEY_F9: FWL_VKEYCODE = 120;
pub const FWL_VKEYCODE_FWL_VKEY_F10: FWL_VKEYCODE = 121;
pub const FWL_VKEYCODE_FWL_VKEY_F11: FWL_VKEYCODE = 122;
pub const FWL_VKEYCODE_FWL_VKEY_F12: FWL_VKEYCODE = 123;
pub const FWL_VKEYCODE_FWL_VKEY_F13: FWL_VKEYCODE = 124;
pub const FWL_VKEYCODE_FWL_VKEY_F14: FWL_VKEYCODE = 125;
pub const FWL_VKEYCODE_FWL_VKEY_F15: FWL_VKEYCODE = 126;
pub const FWL_VKEYCODE_FWL_VKEY_F16: FWL_VKEYCODE = 127;
pub const FWL_VKEYCODE_FWL_VKEY_F17: FWL_VKEYCODE = 128;
pub const FWL_VKEYCODE_FWL_VKEY_F18: FWL_VKEYCODE = 129;
pub const FWL_VKEYCODE_FWL_VKEY_F19: FWL_VKEYCODE = 130;
pub const FWL_VKEYCODE_FWL_VKEY_F20: FWL_VKEYCODE = 131;
pub const FWL_VKEYCODE_FWL_VKEY_F21: FWL_VKEYCODE = 132;
pub const FWL_VKEYCODE_FWL_VKEY_F22: FWL_VKEYCODE = 133;
pub const FWL_VKEYCODE_FWL_VKEY_F23: FWL_VKEYCODE = 134;
pub const FWL_VKEYCODE_FWL_VKEY_F24: FWL_VKEYCODE = 135;
pub const FWL_VKEYCODE_FWL_VKEY_NunLock: FWL_VKEYCODE = 144;
pub const FWL_VKEYCODE_FWL_VKEY_Scroll: FWL_VKEYCODE = 145;
pub const FWL_VKEYCODE_FWL_VKEY_LShift: FWL_VKEYCODE = 160;
pub const FWL_VKEYCODE_FWL_VKEY_RShift: FWL_VKEYCODE = 161;
pub const FWL_VKEYCODE_FWL_VKEY_LControl: FWL_VKEYCODE = 162;
pub const FWL_VKEYCODE_FWL_VKEY_RControl: FWL_VKEYCODE = 163;
pub const FWL_VKEYCODE_FWL_VKEY_LMenu: FWL_VKEYCODE = 164;
pub const FWL_VKEYCODE_FWL_VKEY_RMenu: FWL_VKEYCODE = 165;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Back: FWL_VKEYCODE = 166;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Forward: FWL_VKEYCODE = 167;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Refresh: FWL_VKEYCODE = 168;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Stop: FWL_VKEYCODE = 169;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Search: FWL_VKEYCODE = 170;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Favorites: FWL_VKEYCODE = 171;
pub const FWL_VKEYCODE_FWL_VKEY_BROWSER_Home: FWL_VKEYCODE = 172;
pub const FWL_VKEYCODE_FWL_VKEY_VOLUME_Mute: FWL_VKEYCODE = 173;
pub const FWL_VKEYCODE_FWL_VKEY_VOLUME_Down: FWL_VKEYCODE = 174;
pub const FWL_VKEYCODE_FWL_VKEY_VOLUME_Up: FWL_VKEYCODE = 175;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_NEXT_Track: FWL_VKEYCODE = 176;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_PREV_Track: FWL_VKEYCODE = 177;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_Stop: FWL_VKEYCODE = 178;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_PLAY_Pause: FWL_VKEYCODE = 179;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_LAUNCH_Mail: FWL_VKEYCODE = 180;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_LAUNCH_MEDIA_Select: FWL_VKEYCODE = 181;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_LAUNCH_APP1: FWL_VKEYCODE = 182;
pub const FWL_VKEYCODE_FWL_VKEY_MEDIA_LAUNCH_APP2: FWL_VKEYCODE = 183;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_1: FWL_VKEYCODE = 186;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_Plus: FWL_VKEYCODE = 187;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_Comma: FWL_VKEYCODE = 188;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_Minus: FWL_VKEYCODE = 189;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_Period: FWL_VKEYCODE = 190;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_2: FWL_VKEYCODE = 191;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_3: FWL_VKEYCODE = 192;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_4: FWL_VKEYCODE = 219;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_5: FWL_VKEYCODE = 220;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_6: FWL_VKEYCODE = 221;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_7: FWL_VKEYCODE = 222;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_8: FWL_VKEYCODE = 223;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_102: FWL_VKEYCODE = 226;
pub const FWL_VKEYCODE_FWL_VKEY_ProcessKey: FWL_VKEYCODE = 229;
pub const FWL_VKEYCODE_FWL_VKEY_Packet: FWL_VKEYCODE = 231;
pub const FWL_VKEYCODE_FWL_VKEY_Attn: FWL_VKEYCODE = 246;
pub const FWL_VKEYCODE_FWL_VKEY_Crsel: FWL_VKEYCODE = 247;
pub const FWL_VKEYCODE_FWL_VKEY_Exsel: FWL_VKEYCODE = 248;
pub const FWL_VKEYCODE_FWL_VKEY_Ereof: FWL_VKEYCODE = 249;
pub const FWL_VKEYCODE_FWL_VKEY_Play: FWL_VKEYCODE = 250;
pub const FWL_VKEYCODE_FWL_VKEY_Zoom: FWL_VKEYCODE = 251;
pub const FWL_VKEYCODE_FWL_VKEY_NoName: FWL_VKEYCODE = 252;
pub const FWL_VKEYCODE_FWL_VKEY_PA1: FWL_VKEYCODE = 253;
pub const FWL_VKEYCODE_FWL_VKEY_OEM_Clear: FWL_VKEYCODE = 254;
pub const FWL_VKEYCODE_FWL_VKEY_Unknown: FWL_VKEYCODE = 0;
#[doc = " Virtual keycodes."]
pub type FWL_VKEYCODE = ::std::os::raw::c_uint;
#[doc = " IFPDF_RENDERINFO interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IFSDK_PAUSE {
    #[doc = " Version number of the interface. Currently must be 1."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Method: NeedToPauseNow"]
    #[doc = "           Check if we need to pause a progressive process now."]
    #[doc = " Interface Version:"]
    #[doc = "           1"]
    #[doc = " Implementation Required:"]
    #[doc = "           yes"]
    #[doc = " Parameters:"]
    #[doc = "           pThis       -   Pointer to the interface structure itself"]
    #[doc = " Return Value:"]
    #[doc = "           Non-zero for pause now, 0 for continue."]
    pub NeedToPauseNow:
        ::std::option::Option<unsafe extern "C" fn(pThis: *mut _IFSDK_PAUSE) -> FPDF_BOOL>,
    #[doc = " A user defined data pointer, used by user's application. Can be NULL."]
    pub user: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__IFSDK_PAUSE() {
    assert_eq!(
        ::std::mem::size_of::<_IFSDK_PAUSE>(),
        12usize,
        concat!("Size of: ", stringify!(_IFSDK_PAUSE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IFSDK_PAUSE>(),
        4usize,
        concat!("Alignment of ", stringify!(_IFSDK_PAUSE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IFSDK_PAUSE>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IFSDK_PAUSE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IFSDK_PAUSE>())).NeedToPauseNow as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IFSDK_PAUSE),
            "::",
            stringify!(NeedToPauseNow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IFSDK_PAUSE>())).user as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IFSDK_PAUSE),
            "::",
            stringify!(user)
        )
    );
}
#[doc = " IFPDF_RENDERINFO interface."]
pub type IFSDK_PAUSE = _IFSDK_PAUSE;
#[doc = " Structure for custom file write"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_FILEWRITE_ {
    #[doc = ""]
    #[doc = " Version number of the interface. Currently must be 1."]
    #[doc = ""]
    pub version: ::std::os::raw::c_int,
    #[doc = " Method: WriteBlock"]
    #[doc = "          Output a block of data in your custom way."]
    #[doc = " Interface Version:"]
    #[doc = "          1"]
    #[doc = " Implementation Required:"]
    #[doc = "          Yes"]
    #[doc = " Comments:"]
    #[doc = "          Called by function FPDF_SaveDocument"]
    #[doc = " Parameters:"]
    #[doc = "          pThis       -   Pointer to the structure itself"]
    #[doc = "          pData       -   Pointer to a buffer to output"]
    #[doc = "          size        -   The size of the buffer."]
    #[doc = " Return value:"]
    #[doc = "          Should be non-zero if successful, zero for error."]
    pub WriteBlock: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut FPDF_FILEWRITE_,
            pData: *const ::std::os::raw::c_void,
            size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_FPDF_FILEWRITE_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_FILEWRITE_>(),
        8usize,
        concat!("Size of: ", stringify!(FPDF_FILEWRITE_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_FILEWRITE_>(),
        4usize,
        concat!("Alignment of ", stringify!(FPDF_FILEWRITE_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEWRITE_>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEWRITE_),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_FILEWRITE_>())).WriteBlock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_FILEWRITE_),
            "::",
            stringify!(WriteBlock)
        )
    );
}
#[doc = " Structure for custom file write"]
pub type FPDF_FILEWRITE = FPDF_FILEWRITE_;
#[doc = " Interface: FPDF_SYSFONTINFO"]
#[doc = "          Interface for getting system font information and font mapping"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPDF_SYSFONTINFO {
    #[doc = " Version number of the interface. Currently must be 1."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Method: Release"]
    #[doc = "          Give implementation a chance to release any data after the"]
    #[doc = "          interface is no longer used."]
    #[doc = " Interface Version:"]
    #[doc = "          1"]
    #[doc = " Implementation Required:"]
    #[doc = "          No"]
    #[doc = " Parameters:"]
    #[doc = "          pThis       -   Pointer to the interface structure itself"]
    #[doc = " Return Value:"]
    #[doc = "          None"]
    #[doc = " Comments:"]
    #[doc = "          Called by PDFium during the final cleanup process."]
    pub Release: ::std::option::Option<unsafe extern "C" fn(pThis: *mut _FPDF_SYSFONTINFO)>,
    #[doc = " Method: EnumFonts"]
    #[doc = "          Enumerate all fonts installed on the system"]
    #[doc = " Interface Version:"]
    #[doc = "          1"]
    #[doc = " Implementation Required:"]
    #[doc = "          No"]
    #[doc = " Parameters:"]
    #[doc = "          pThis       -   Pointer to the interface structure itself"]
    #[doc = "          pMapper     -   An opaque pointer to internal font mapper, used"]
    #[doc = "                          when calling FPDF_AddInstalledFont()."]
    #[doc = " Return Value:"]
    #[doc = "          None"]
    #[doc = " Comments:"]
    #[doc = "          Implementations should call FPDF_AddIntalledFont() function for"]
    #[doc = "          each font found. Only TrueType/OpenType and Type1 fonts are accepted"]
    #[doc = "          by PDFium."]
    pub EnumFonts: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_SYSFONTINFO, pMapper: *mut ::std::os::raw::c_void),
    >,
    #[doc = " Method: MapFont"]
    #[doc = "          Use the system font mapper to get a font handle from requested"]
    #[doc = "          parameters."]
    #[doc = " Interface Version:"]
    #[doc = "          1"]
    #[doc = " Implementation Required:"]
    #[doc = "          Required if GetFont method is not implemented."]
    #[doc = " Parameters:"]
    #[doc = "          pThis       -   Pointer to the interface structure itself"]
    #[doc = "          weight      -   Weight of the requested font. 400 is normal and"]
    #[doc = "                          700 is bold."]
    #[doc = "          bItalic     -   Italic option of the requested font, TRUE or"]
    #[doc = "                          FALSE."]
    #[doc = "          charset     -   Character set identifier for the requested font."]
    #[doc = "                          See above defined constants."]
    #[doc = "          pitch_family -  A combination of flags. See above defined"]
    #[doc = "                          constants."]
    #[doc = "          face        -   Typeface name. Currently use system local encoding"]
    #[doc = "                          only."]
    #[doc = "          bExact      -   Obsolete: this parameter is now ignored."]
    #[doc = " Return Value:"]
    #[doc = "          An opaque pointer for font handle, or NULL if system mapping is"]
    #[doc = "          not supported."]
    #[doc = " Comments:"]
    #[doc = "          If the system supports native font mapper (like Windows),"]
    #[doc = "          implementation can implement this method to get a font handle."]
    #[doc = "          Otherwise, PDFium will do the mapping and then call GetFont"]
    #[doc = "          method. Only TrueType/OpenType and Type1 fonts are accepted"]
    #[doc = "          by PDFium."]
    pub MapFont: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_SYSFONTINFO,
            weight: ::std::os::raw::c_int,
            bItalic: FPDF_BOOL,
            charset: ::std::os::raw::c_int,
            pitch_family: ::std::os::raw::c_int,
            face: *const ::std::os::raw::c_char,
            bExact: *mut FPDF_BOOL,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Method: GetFont"]
    #[doc = "          Get a handle to a particular font by its internal ID"]
    #[doc = " Interface Version:"]
    #[doc = "          1"]
    #[doc = " Implementation Required:"]
    #[doc = "          Required if MapFont method is not implemented."]
    #[doc = " Return Value:"]
    #[doc = "          An opaque pointer for font handle."]
    #[doc = " Parameters:"]
    #[doc = "          pThis       -   Pointer to the interface structure itself"]
    #[doc = "          face        -   Typeface name in system local encoding."]
    #[doc = " Comments:"]
    #[doc = "          If the system mapping not supported, PDFium will do the font"]
    #[doc = "          mapping and use this method to get a font handle."]
    pub GetFont: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_SYSFONTINFO,
            face: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Method: GetFontData"]
    #[doc = "          Get font data from a font"]
    #[doc = " Interface Version:"]
    #[doc = "          1"]
    #[doc = " Implementation Required:"]
    #[doc = "          Yes"]
    #[doc = " Parameters:"]
    #[doc = "          pThis       -   Pointer to the interface structure itself"]
    #[doc = "          hFont       -   Font handle returned by MapFont or GetFont method"]
    #[doc = "          table       -   TrueType/OpenType table identifier (refer to"]
    #[doc = "                          TrueType specification), or 0 for the whole file."]
    #[doc = "          buffer      -   The buffer receiving the font data. Can be NULL if"]
    #[doc = "                          not provided."]
    #[doc = "          buf_size    -   Buffer size, can be zero if not provided."]
    #[doc = " Return Value:"]
    #[doc = "          Number of bytes needed, if buffer not provided or not large"]
    #[doc = "          enough, or number of bytes written into buffer otherwise."]
    #[doc = " Comments:"]
    #[doc = "          Can read either the full font file, or a particular"]
    #[doc = "          TrueType/OpenType table."]
    pub GetFontData: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_SYSFONTINFO,
            hFont: *mut ::std::os::raw::c_void,
            table: ::std::os::raw::c_uint,
            buffer: *mut ::std::os::raw::c_uchar,
            buf_size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong,
    >,
    #[doc = " Method: GetFaceName"]
    #[doc = "          Get face name from a font handle"]
    #[doc = " Interface Version:"]
    #[doc = "          1"]
    #[doc = " Implementation Required:"]
    #[doc = "          No"]
    #[doc = " Parameters:"]
    #[doc = "          pThis       -   Pointer to the interface structure itself"]
    #[doc = "          hFont       -   Font handle returned by MapFont or GetFont method"]
    #[doc = "          buffer      -   The buffer receiving the face name. Can be NULL if"]
    #[doc = "                          not provided"]
    #[doc = "          buf_size    -   Buffer size, can be zero if not provided"]
    #[doc = " Return Value:"]
    #[doc = "          Number of bytes needed, if buffer not provided or not large"]
    #[doc = "          enough, or number of bytes written into buffer otherwise."]
    pub GetFaceName: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_SYSFONTINFO,
            hFont: *mut ::std::os::raw::c_void,
            buffer: *mut ::std::os::raw::c_char,
            buf_size: ::std::os::raw::c_ulong,
        ) -> ::std::os::raw::c_ulong,
    >,
    #[doc = " Method: GetFontCharset"]
    #[doc = "          Get character set information for a font handle"]
    #[doc = " Interface Version:"]
    #[doc = "          1"]
    #[doc = " Implementation Required:"]
    #[doc = "          No"]
    #[doc = " Parameters:"]
    #[doc = "          pThis       -   Pointer to the interface structure itself"]
    #[doc = "          hFont       -   Font handle returned by MapFont or GetFont method"]
    #[doc = " Return Value:"]
    #[doc = "          Character set identifier. See defined constants above."]
    pub GetFontCharset: ::std::option::Option<
        unsafe extern "C" fn(
            pThis: *mut _FPDF_SYSFONTINFO,
            hFont: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Method: DeleteFont"]
    #[doc = "          Delete a font handle"]
    #[doc = " Interface Version:"]
    #[doc = "          1"]
    #[doc = " Implementation Required:"]
    #[doc = "          Yes"]
    #[doc = " Parameters:"]
    #[doc = "          pThis       -   Pointer to the interface structure itself"]
    #[doc = "          hFont       -   Font handle returned by MapFont or GetFont method"]
    #[doc = " Return Value:"]
    #[doc = "          None"]
    pub DeleteFont: ::std::option::Option<
        unsafe extern "C" fn(pThis: *mut _FPDF_SYSFONTINFO, hFont: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout__FPDF_SYSFONTINFO() {
    assert_eq!(
        ::std::mem::size_of::<_FPDF_SYSFONTINFO>(),
        36usize,
        concat!("Size of: ", stringify!(_FPDF_SYSFONTINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_FPDF_SYSFONTINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_FPDF_SYSFONTINFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSFONTINFO>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSFONTINFO>())).Release as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(Release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSFONTINFO>())).EnumFonts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(EnumFonts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSFONTINFO>())).MapFont as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(MapFont)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSFONTINFO>())).GetFont as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(GetFont)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSFONTINFO>())).GetFontData as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(GetFontData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSFONTINFO>())).GetFaceName as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(GetFaceName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FPDF_SYSFONTINFO>())).GetFontCharset as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(GetFontCharset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPDF_SYSFONTINFO>())).DeleteFont as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPDF_SYSFONTINFO),
            "::",
            stringify!(DeleteFont)
        )
    );
}
#[doc = " Interface: FPDF_SYSFONTINFO"]
#[doc = "          Interface for getting system font information and font mapping"]
pub type FPDF_SYSFONTINFO = _FPDF_SYSFONTINFO;
#[doc = " Struct: FPDF_CharsetFontMap"]
#[doc = "    Provides the name of a font to use for a given charset value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPDF_CharsetFontMap_ {
    #[doc = " Character Set Enum value, see FXFONT_*_CHARSET above."]
    pub charset: ::std::os::raw::c_int,
    #[doc = " Name of default font to use with that charset."]
    pub fontname: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_FPDF_CharsetFontMap_() {
    assert_eq!(
        ::std::mem::size_of::<FPDF_CharsetFontMap_>(),
        8usize,
        concat!("Size of: ", stringify!(FPDF_CharsetFontMap_))
    );
    assert_eq!(
        ::std::mem::align_of::<FPDF_CharsetFontMap_>(),
        4usize,
        concat!("Alignment of ", stringify!(FPDF_CharsetFontMap_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_CharsetFontMap_>())).charset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_CharsetFontMap_),
            "::",
            stringify!(charset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPDF_CharsetFontMap_>())).fontname as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPDF_CharsetFontMap_),
            "::",
            stringify!(fontname)
        )
    );
}
#[doc = " Struct: FPDF_CharsetFontMap"]
#[doc = "    Provides the name of a font to use for a given charset value."]
pub type FPDF_CharsetFontMap = FPDF_CharsetFontMap_;
